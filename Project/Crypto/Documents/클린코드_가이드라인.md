# 클린 코드 가이드라인
## Clean Code Guidelines for Crypto Auto-Trading System

---

## 📋 문서 정보

| 항목 | 내용 |
|------|------|
| **문서명** | 클린 코드 가이드라인 |
| **버전** | v1.0 |
| **작성일** | 2025년 8월 31일 |
| **대상** | 모든 개발 에이전트 |
| **목적** | 일관된 코드 품질 및 유지보수성 확보 |

---

## 🎯 1. 클린 코드 철학

### 1.1 핵심 원칙
**"코드는 사람이 읽기 위해 작성되며, 기계가 실행하는 것은 부차적이다"**

```python
# ❌ 나쁜 예
def calc(d, r, t):
    return d * (1 + r) ** t

# ✅ 좋은 예
def calculate_compound_interest(principal: float, rate: float, time: int) -> float:
    """
    복리 이자를 계산합니다.
    
    Args:
        principal: 원금
        rate: 연이율 (소수점 형태, 예: 0.05 = 5%)
        time: 투자 기간 (년)
    
    Returns:
        복리 이자가 적용된 최종 금액
    """
    return principal * (1 + rate) ** time
```

### 1.2 품질 지표
- **가독성**: 코드를 처음 보는 사람도 5분 내에 이해 가능
- **유지보수성**: 기능 변경 시 최소한의 코드 수정
- **테스트 가능성**: 모든 함수가 독립적으로 테스트 가능
- **성능**: 요구사항을 만족하는 최적의 성능

---

## 🏗️ 2. 아키텍처 설계 원칙

### 2.1 SOLID 원칙

**Single Responsibility Principle (단일 책임 원칙)**
```python
# ❌ 나쁜 예: 여러 책임을 가진 클래스
class TradingManager:
    def get_market_data(self):
        pass
    
    def calculate_signals(self):
        pass
    
    def execute_orders(self):
        pass
    
    def send_notifications(self):
        pass

# ✅ 좋은 예: 단일 책임으로 분리
class MarketDataProvider:
    """시장 데이터 제공 전용"""
    def get_market_data(self) -> MarketData:
        pass

class SignalCalculator:
    """신호 계산 전용"""
    def calculate_signals(self, data: MarketData) -> List[Signal]:
        pass

class OrderExecutor:
    """주문 실행 전용"""
    def execute_orders(self, signals: List[Signal]) -> List[Order]:
        pass

class NotificationService:
    """알림 전송 전용"""
    def send_notifications(self, orders: List[Order]) -> None:
        pass
```

**Open/Closed Principle (개방/폐쇄 원칙)**
```python
from abc import ABC, abstractmethod

# ✅ 확장에는 열려있고, 수정에는 닫혀있는 설계
class EntryCondition(ABC):
    """진입 조건 추상 클래스"""
    
    @abstractmethod
    def evaluate(self, market_data: MarketData) -> Signal:
        pass
    
    @abstractmethod
    def is_active(self) -> bool:
        pass

class MovingAverageCondition(EntryCondition):
    """이동평균 조건 - 새로운 조건 추가 시 기존 코드 수정 불필요"""
    
    def __init__(self, period: int, condition_type: str):
        self.period = period
        self.condition_type = condition_type
        self._active = True
    
    def evaluate(self, market_data: MarketData) -> Signal:
        ma_value = self._calculate_moving_average(market_data)
        current_price = market_data.close
        
        if self.condition_type == "close_above" and current_price > ma_value:
            return Signal("BUY", current_price, confidence=0.8)
        elif self.condition_type == "close_below" and current_price < ma_value:
            return Signal("SELL", current_price, confidence=0.8)
        
        return None
    
    def is_active(self) -> bool:
        return self._active

class PriceChannelCondition(EntryCondition):
    """Price Channel 조건 - 기존 코드 수정 없이 새 조건 추가"""
    
    def evaluate(self, market_data: MarketData) -> Signal:
        # Price Channel 로직 구현
        pass
    
    def is_active(self) -> bool:
        return self._active
```

**Liskov Substitution Principle (리스코프 치환 원칙)**
```python
# ✅ 부모 클래스를 자식 클래스로 치환 가능한 설계
class APIConnector(ABC):
    @abstractmethod
    async def get_account_info(self) -> AccountInfo:
        pass
    
    @abstractmethod
    async def place_order(self, order: Order) -> OrderResult:
        pass

class BinanceConnector(APIConnector):
    async def get_account_info(self) -> AccountInfo:
        # 바이낸스 API 호출
        response = await self._api_call("/fapi/v2/account")
        return AccountInfo.from_binance_response(response)
    
    async def place_order(self, order: Order) -> OrderResult:
        # 바이낸스 주문 실행
        response = await self._api_call("/fapi/v1/order", order.to_binance_params())
        return OrderResult.from_binance_response(response)

class BybitConnector(APIConnector):
    async def get_account_info(self) -> AccountInfo:
        # 바이비트 API 호출 - 같은 인터페이스, 다른 구현
        response = await self._api_call("/v2/private/wallet/balance")
        return AccountInfo.from_bybit_response(response)
    
    async def place_order(self, order: Order) -> OrderResult:
        # 바이비트 주문 실행
        response = await self._api_call("/private/linear/order/create", order.to_bybit_params())
        return OrderResult.from_bybit_response(response)

# 사용 시 - 어떤 구현체든 동일하게 사용 가능
async def execute_trading_logic(connector: APIConnector):
    account = await connector.get_account_info()  # 어떤 거래소든 동일한 방식
    if account.has_sufficient_balance():
        order = Order("BUY", "BTCUSDT", 0.1)
        result = await connector.place_order(order)
```

### 2.2 의존성 주입 (Dependency Injection)

```python
# ✅ 의존성 주입을 통한 유연한 설계
class TradingEngine:
    def __init__(self, 
                 data_provider: MarketDataProvider,
                 signal_calculator: SignalCalculator,
                 order_executor: OrderExecutor,
                 risk_manager: RiskManager,
                 logger: Logger):
        self.data_provider = data_provider
        self.signal_calculator = signal_calculator
        self.order_executor = order_executor
        self.risk_manager = risk_manager
        self.logger = logger
    
    async def run_trading_cycle(self):
        """거래 사이클 실행"""
        try:
            # 1. 시장 데이터 수집
            market_data = await self.data_provider.get_latest_data()
            
            # 2. 신호 계산
            signals = self.signal_calculator.calculate_signals(market_data)
            
            # 3. 리스크 검증
            validated_signals = self.risk_manager.validate_signals(signals)
            
            # 4. 주문 실행
            if validated_signals:
                orders = await self.order_executor.execute_orders(validated_signals)
                self.logger.info(f"Executed {len(orders)} orders")
        
        except Exception as e:
            self.logger.error(f"Trading cycle failed: {e}")
            raise

# 의존성 조립 (Dependency Assembly)
def create_trading_engine() -> TradingEngine:
    """거래 엔진 생성 - 의존성 주입"""
    config = load_config()
    
    # 의존성 생성
    data_provider = BinanceDataProvider(config.api_key, config.secret)
    signal_calculator = SignalCalculator(config.entry_conditions)
    order_executor = OrderExecutor(data_provider.api_connector)
    risk_manager = RiskManager(config.risk_settings)
    logger = create_logger("trading_engine")
    
    # 엔진 생성 및 반환
    return TradingEngine(
        data_provider=data_provider,
        signal_calculator=signal_calculator,
        order_executor=order_executor,
        risk_manager=risk_manager,
        logger=logger
    )
```

---

## 📝 3. 네이밍 컨벤션

### 3.1 변수 및 함수명

**명확하고 의미 있는 이름 사용**
```python
# ❌ 나쁜 예
d = 50000.0  # 무엇을 의미하는지 불분명
calc_pnl(p, e)  # 약어 사용으로 의미 파악 어려움

# ✅ 좋은 예
current_btc_price = 50000.0
calculate_profit_and_loss(position: Position, exit_price: float)
```

**동사 + 명사 패턴 (함수)**
```python
# ✅ 함수명은 동작을 명확히 표현
def validate_order_parameters(order: Order) -> bool:
    """주문 파라미터 검증"""
    pass

def calculate_position_size(account_balance: float, risk_percentage: float) -> float:
    """포지션 크기 계산"""
    pass

def execute_market_order(symbol: str, side: str, quantity: float) -> OrderResult:
    """시장가 주문 실행"""
    pass
```

**불린 변수 및 함수**
```python
# ✅ is_, has_, can_, should_ 접두사 사용
is_position_open = True
has_sufficient_balance = account.balance > required_amount
can_place_order = risk_manager.validate_order(order)

def is_market_open() -> bool:
    """시장 개장 여부 확인"""
    pass

def has_active_positions() -> bool:
    """활성 포지션 존재 여부"""
    pass

def can_execute_order(order: Order) -> bool:
    """주문 실행 가능 여부"""
    pass
```

### 3.2 클래스명

**명사 사용, PascalCase**
```python
# ✅ 클래스명은 명사로, 역할을 명확히 표현
class TradingEngine:
    """거래 엔진"""
    pass

class MarketDataProvider:
    """시장 데이터 제공자"""
    pass

class RiskManager:
    """리스크 관리자"""
    pass

class OrderExecutor:
    """주문 실행자"""
    pass
```

### 3.3 상수명

**대문자 + 언더스코어**
```python
# ✅ 상수는 대문자로 명명
MAX_POSITION_SIZE = 1000.0
DEFAULT_LEVERAGE = 10
API_TIMEOUT_SECONDS = 30
WEBSOCKET_RECONNECT_DELAY = 5

# 설정 그룹화
class TradingConfig:
    MAX_POSITIONS = 5
    DEFAULT_STOP_LOSS_PERCENTAGE = 0.02
    DEFAULT_TAKE_PROFIT_PERCENTAGE = 0.04
    ORDER_TIMEOUT_SECONDS = 60
```

---

## 🔧 4. 함수 설계 원칙

### 4.1 함수 크기 및 복잡성

**작고 단순한 함수**
```python
# ❌ 나쁜 예: 너무 긴 함수
def process_trading_signals(market_data):
    # 50줄 이상의 복잡한 로직...
    pass

# ✅ 좋은 예: 작고 명확한 함수들로 분리
def calculate_moving_average(prices: List[float], period: int) -> float:
    """이동평균 계산"""
    if len(prices) < period:
        raise ValueError(f"Insufficient data: need {period}, got {len(prices)}")
    
    return sum(prices[-period:]) / period

def evaluate_ma_condition(current_price: float, ma_value: float, condition_type: str) -> Optional[Signal]:
    """이동평균 조건 평가"""
    if condition_type == "close_above" and current_price > ma_value:
        return Signal("BUY", current_price, confidence=0.8)
    elif condition_type == "close_below" and current_price < ma_value:
        return Signal("SELL", current_price, confidence=0.8)
    
    return None

def process_ma_signals(market_data: MarketData, ma_config: MAConfig) -> List[Signal]:
    """이동평균 신호 처리"""
    signals = []
    
    for config in ma_config.conditions:
        ma_value = calculate_moving_average(market_data.close_prices, config.period)
        signal = evaluate_ma_condition(market_data.current_price, ma_value, config.type)
        
        if signal:
            signals.append(signal)
    
    return signals
```

### 4.2 매개변수 관리

**매개변수 개수 제한 (최대 3-4개)**
```python
# ❌ 나쁜 예: 매개변수가 너무 많음
def create_order(symbol, side, quantity, order_type, price, stop_price, time_in_force, reduce_only, close_position):
    pass

# ✅ 좋은 예: 객체로 그룹화
@dataclass
class OrderParams:
    symbol: str
    side: str  # "BUY" or "SELL"
    quantity: float
    order_type: str = "MARKET"
    price: Optional[float] = None
    stop_price: Optional[float] = None
    time_in_force: str = "GTC"
    reduce_only: bool = False
    close_position: bool = False

def create_order(params: OrderParams) -> Order:
    """주문 생성"""
    return Order(
        symbol=params.symbol,
        side=params.side,
        quantity=params.quantity,
        order_type=params.order_type,
        price=params.price,
        stop_price=params.stop_price,
        time_in_force=params.time_in_force,
        reduce_only=params.reduce_only,
        close_position=params.close_position
    )
```

### 4.3 반환값 관리

**명확한 반환 타입**
```python
from typing import Union, Optional, Tuple, List
from dataclasses import dataclass

# ✅ 명확한 반환 타입 정의
@dataclass
class ValidationResult:
    is_valid: bool
    error_message: Optional[str] = None
    warnings: List[str] = None

def validate_order(order: Order) -> ValidationResult:
    """주문 검증"""
    warnings = []
    
    # 기본 검증
    if order.quantity <= 0:
        return ValidationResult(False, "Quantity must be positive")
    
    if order.symbol not in SUPPORTED_SYMBOLS:
        return ValidationResult(False, f"Unsupported symbol: {order.symbol}")
    
    # 경고 사항 체크
    if order.quantity > MAX_POSITION_SIZE:
        warnings.append(f"Large position size: {order.quantity}")
    
    return ValidationResult(True, warnings=warnings)

# 사용 예시
result = validate_order(order)
if not result.is_valid:
    logger.error(f"Order validation failed: {result.error_message}")
    return

if result.warnings:
    for warning in result.warnings:
        logger.warning(warning)
```

---

## 🏛️ 5. 클래스 설계 원칙

### 5.1 캡슐화 (Encapsulation)

**private 멤버 사용**
```python
class Position:
    """포지션 클래스"""
    
    def __init__(self, symbol: str, side: str, quantity: float, entry_price: float):
        self.symbol = symbol
        self.side = side
        self._quantity = quantity  # protected
        self._entry_price = entry_price  # protected
        self.__created_at = datetime.utcnow()  # private
        self.__pnl_cache = None  # private
    
    @property
    def quantity(self) -> float:
        """수량 조회"""
        return self._quantity
    
    @quantity.setter
    def quantity(self, value: float) -> None:
        """수량 설정 - 검증 로직 포함"""
        if value <= 0:
            raise ValueError("Quantity must be positive")
        
        self._quantity = value
        self.__pnl_cache = None  # 캐시 무효화
    
    @property
    def entry_price(self) -> float:
        """진입가 조회"""
        return self._entry_price
    
    def calculate_pnl(self, current_price: float) -> float:
        """손익 계산 - 캐시 활용"""
        cache_key = current_price
        if self.__pnl_cache and self.__pnl_cache[0] == cache_key:
            return self.__pnl_cache[1]
        
        if self.side == "BUY":
            pnl = (current_price - self._entry_price) * self._quantity
        else:  # SELL
            pnl = (self._entry_price - current_price) * self._quantity
        
        self.__pnl_cache = (cache_key, pnl)
        return pnl
    
    def __str__(self) -> str:
        """문자열 표현"""
        return f"Position({self.symbol}, {self.side}, {self._quantity}@{self._entry_price})"
```

### 5.2 상속 vs 컴포지션

**컴포지션 우선 사용**
```python
# ✅ 컴포지션을 통한 유연한 설계
class TradingStrategy:
    """거래 전략 - 컴포지션 활용"""
    
    def __init__(self, 
                 entry_conditions: List[EntryCondition],
                 exit_conditions: List[ExitCondition],
                 risk_manager: RiskManager):
        self.entry_conditions = entry_conditions
        self.exit_conditions = exit_conditions
        self.risk_manager = risk_manager
        self.positions = []
    
    def add_entry_condition(self, condition: EntryCondition) -> None:
        """진입 조건 추가"""
        self.entry_conditions.append(condition)
    
    def remove_entry_condition(self, condition: EntryCondition) -> None:
        """진입 조건 제거"""
        if condition in self.entry_conditions:
            self.entry_conditions.remove(condition)
    
    def evaluate_entry_signals(self, market_data: MarketData) -> List[Signal]:
        """진입 신호 평가"""
        signals = []
        
        for condition in self.entry_conditions:
            if condition.is_active():
                signal = condition.evaluate(market_data)
                if signal and self.risk_manager.validate_signal(signal):
                    signals.append(signal)
        
        return signals

# 사용 예시 - 런타임에 전략 구성 변경 가능
strategy = TradingStrategy(
    entry_conditions=[
        MovingAverageCondition(20, "close_above"),
        PriceChannelCondition("upper_breakout")
    ],
    exit_conditions=[
        PCSExitCondition([1, 2, 3]),
        TrailingStopCondition(10)
    ],
    risk_manager=RiskManager(max_positions=5)
)

# 런타임에 조건 추가/제거
strategy.add_entry_condition(OrderBookCondition(5))
strategy.remove_entry_condition(existing_condition)
```

---

## 🔍 6. 오류 처리

### 6.1 예외 계층 구조

**도메인별 예외 정의**
```python
# 기본 예외 클래스
class TradingSystemError(Exception):
    """거래 시스템 기본 예외"""
    
    def __init__(self, message: str, error_code: str = None, details: dict = None):
        super().__init__(message)
        self.message = message
        self.error_code = error_code
        self.details = details or {}
        self.timestamp = datetime.utcnow()

# 도메인별 예외
class APIError(TradingSystemError):
    """API 관련 예외"""
    pass

class InsufficientBalanceError(TradingSystemError):
    """잔고 부족 예외"""
    pass

class InvalidOrderError(TradingSystemError):
    """잘못된 주문 예외"""
    pass

class RiskLimitExceededError(TradingSystemError):
    """리스크 한도 초과 예외"""
    pass

class MarketDataError(TradingSystemError):
    """시장 데이터 오류"""
    pass

# 구체적인 예외들
class BinanceAPIError(APIError):
    """바이낸스 API 오류"""
    
    def __init__(self, message: str, api_code: int, api_message: str):
        super().__init__(
            message=message,
            error_code=f"BINANCE_{api_code}",
            details={"api_code": api_code, "api_message": api_message}
        )

class BybitAPIError(APIError):
    """바이비트 API 오류"""
    
    def __init__(self, message: str, ret_code: int, ret_msg: str):
        super().__init__(
            message=message,
            error_code=f"BYBIT_{ret_code}",
            details={"ret_code": ret_code, "ret_msg": ret_msg}
        )
```

### 6.2 예외 처리 패턴

**계층별 예외 처리**
```python
class OrderExecutor:
    """주문 실행자"""
    
    async def execute_order(self, order: Order) -> OrderResult:
        """주문 실행 - 계층별 예외 처리"""
        try:
            # 1. 주문 검증
            validation_result = self._validate_order(order)
            if not validation_result.is_valid:
                raise InvalidOrderError(
                    f"Order validation failed: {validation_result.error_message}",
                    error_code="INVALID_ORDER",
                    details={"order": order.to_dict()}
                )
            
            # 2. 잔고 확인
            required_balance = self._calculate_required_balance(order)
            if not await self._check_balance(required_balance):
                raise InsufficientBalanceError(
                    f"Insufficient balance: required {required_balance}",
                    error_code="INSUFFICIENT_BALANCE",
                    details={"required": required_balance, "order": order.to_dict()}
                )
            
            # 3. API 호출
            result = await self._place_order_via_api(order)
            return result
            
        except InvalidOrderError:
            # 주문 오류는 그대로 전파
            raise
        except InsufficientBalanceError:
            # 잔고 부족도 그대로 전파
            raise
        except APIError as e:
            # API 오류는 로깅 후 재시도 또는 전파
            logger.error(f"API error during order execution: {e}")
            if self._should_retry(e):
                return await self._retry_order_execution(order)
            raise
        except Exception as e:
            # 예상치 못한 오류는 래핑해서 전파
            logger.error(f"Unexpected error during order execution: {e}")
            raise TradingSystemError(
                f"Order execution failed: {str(e)}",
                error_code="ORDER_EXECUTION_FAILED",
                details={"order": order.to_dict(), "original_error": str(e)}
            )
    
    async def _retry_order_execution(self, order: Order, max_retries: int = 3) -> OrderResult:
        """주문 실행 재시도"""
        for attempt in range(max_retries):
            try:
                await asyncio.sleep(2 ** attempt)  # 지수 백오프
                result = await self._place_order_via_api(order)
                logger.info(f"Order execution succeeded on retry {attempt + 1}")
                return result
            except APIError as e:
                if attempt == max_retries - 1:  # 마지막 시도
                    raise
                logger.warning(f"Retry {attempt + 1} failed: {e}")
```

### 6.3 로깅과 모니터링

**구조화된 로깅**
```python
import logging
import json
from datetime import datetime
from typing import Any, Dict

class StructuredLogger:
    """구조화된 로깅"""
    
    def __init__(self, name: str):
        self.logger = logging.getLogger(name)
        self._setup_logger()
    
    def _setup_logger(self):
        """로거 설정"""
        handler = logging.StreamHandler()
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        handler.setFormatter(formatter)
        self.logger.addHandler(handler)
        self.logger.setLevel(logging.INFO)
    
    def _log_structured(self, level: str, message: str, **kwargs):
        """구조화된 로그 출력"""
        log_data = {
            "timestamp": datetime.utcnow().isoformat(),
            "level": level,
            "message": message,
            **kwargs
        }
        
        getattr(self.logger, level.lower())(json.dumps(log_data, default=str))
    
    def info(self, message: str, **kwargs):
        """정보 로그"""
        self._log_structured("INFO", message, **kwargs)
    
    def error(self, message: str, **kwargs):
        """오류 로그"""
        self._log_structured("ERROR", message, **kwargs)
    
    def warning(self, message: str, **kwargs):
        """경고 로그"""
        self._log_structured("WARNING", message, **kwargs)

# 사용 예시
logger = StructuredLogger("trading_engine")

# 주문 실행 로그
logger.info(
    "Order executed successfully",
    order_id="12345",
    symbol="BTCUSDT",
    side="BUY",
    quantity=0.1,
    price=50000.0,
    execution_time_ms=150
)

# 오류 로그
logger.error(
    "Order execution failed",
    order_id="12346",
    symbol="ETHUSDT",
    error_code="INSUFFICIENT_BALANCE",
    error_message="Insufficient balance for order",
    required_balance=1000.0,
    available_balance=500.0
)
```

---

## ⚡ 7. 성능 최적화

### 7.1 비동기 프로그래밍

**asyncio 활용**
```python
import asyncio
import aiohttp
from typing import List, Dict, Any

class AsyncMarketDataProvider:
    """비동기 시장 데이터 제공자"""
    
    def __init__(self):
        self.session = None
        self._data_cache = {}
        self._cache_ttl = 1  # 1초 캐시
    
    async def __aenter__(self):
        """비동기 컨텍스트 매니저 진입"""
        self.session = aiohttp.ClientSession()
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """비동기 컨텍스트 매니저 종료"""
        if self.session:
            await self.session.close()
    
    async def get_multiple_tickers(self, symbols: List[str]) -> Dict[str, Dict[str, Any]]:
        """여러 심볼의 티커 데이터 동시 조회"""
        tasks = [self._get_ticker(symbol) for symbol in symbols]
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        ticker_data = {}
        for symbol, result in zip(symbols, results):
            if isinstance(result, Exception):
                logger.error(f"Failed to get ticker for {symbol}: {result}")
                continue
            ticker_data[symbol] = result
        
        return ticker_data
    
    async def _get_ticker(self, symbol: str) -> Dict[str, Any]:
        """단일 심볼 티커 조회 - 캐시 활용"""
        cache_key = f"ticker_{symbol}"
        cached_data = self._get_cached_data(cache_key)
        
        if cached_data:
            return cached_data
        
        url = f"https://fapi.binance.com/fapi/v1/ticker/24hr?symbol={symbol}"
        
        async with self.session.get(url) as response:
            if response.status == 200:
                data = await response.json()
                self._cache_data(cache_key, data)
                return data
            else:
                raise APIError(f"Failed to get ticker for {symbol}: {response.status}")
    
    def _get_cached_data(self, key: str) -> Optional[Dict[str, Any]]:
        """캐시 데이터 조회"""
        if key in self._data_cache:
            cached_time, data = self._data_cache[key]
            if time.time() - cached_time < self._cache_ttl:
                return data
        return None
    
    def _cache_data(self, key: str, data: Dict[str, Any]) -> None:
        """데이터 캐시"""
        self._data_cache[key] = (time.time(), data)

# 사용 예시
async def main():
    symbols = ["BTCUSDT", "ETHUSDT", "ADAUSDT", "DOTUSDT"]
    
    async with AsyncMarketDataProvider() as provider:
        ticker_data = await provider.get_multiple_tickers(symbols)
        
        for symbol, data in ticker_data.items():
            print(f"{symbol}: {data['lastPrice']}")

# 실행
asyncio.run(main())
```

### 7.2 메모리 최적화

**메모리 효율적인 데이터 구조**
```python
from dataclasses import dataclass
from typing import NamedTuple
import sys

# ❌ 메모리 비효율적
class MarketDataDict:
    def __init__(self, symbol, price, volume, timestamp):
        self.symbol = symbol
        self.price = price
        self.volume = volume
        self.timestamp = timestamp

# ✅ 메모리 효율적 - NamedTuple 사용
class MarketData(NamedTuple):
    symbol: str
    price: float
    volume: float
    timestamp: int

# ✅ 메모리 효율적 - dataclass with slots
@dataclass(frozen=True)
class OptimizedMarketData:
    __slots__ = ['symbol', 'price', 'volume', 'timestamp']
    
    symbol: str
    price: float
    volume: float
    timestamp: int

# 메모리 사용량 비교
data_dict = MarketDataDict("BTCUSDT", 50000.0, 1000.0, 1234567890)
data_tuple = MarketData("BTCUSDT", 50000.0, 1000.0, 1234567890)
data_optimized = OptimizedMarketData("BTCUSDT", 50000.0, 1000.0, 1234567890)

print(f"Dict size: {sys.getsizeof(data_dict)} bytes")
print(f"NamedTuple size: {sys.getsizeof(data_tuple)} bytes")
print(f"Optimized dataclass size: {sys.getsizeof(data_optimized)} bytes")
```

### 7.3 데이터베이스 최적화

**효율적인 쿼리 및 인덱싱**
```python
import sqlite3
from typing import List, Optional
from contextlib import contextmanager

class TradingDatabase:
    """거래 데이터베이스 - 최적화된 쿼리"""
    
    def __init__(self, db_path: str):
        self.db_path = db_path
        self._init_database()
    
    def _init_database(self):
        """데이터베이스 초기화"""
        with self._get_connection() as conn:
            # 테이블 생성
            conn.execute("""
                CREATE TABLE IF NOT EXISTS trades (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    symbol TEXT NOT NULL,
                    side TEXT NOT NULL,
                    quantity REAL NOT NULL,
                    price REAL NOT NULL,
                    timestamp INTEGER NOT NULL,
                    order_id TEXT UNIQUE NOT NULL
                )
            """)
            
            # 인덱스 생성 - 자주 조회되는 컬럼
            conn.execute("CREATE INDEX IF NOT EXISTS idx_trades_symbol ON trades(symbol)")
            conn.execute("CREATE INDEX IF NOT EXISTS idx_trades_timestamp ON trades(timestamp)")
            conn.execute("CREATE INDEX IF NOT EXISTS idx_trades_order_id ON trades(order_id)")
            
            # 복합 인덱스 - 함께 조회되는 컬럼들
            conn.execute("CREATE INDEX IF NOT EXISTS idx_trades_symbol_timestamp ON trades(symbol, timestamp)")
    
    @contextmanager
    def _get_connection(self):
        """데이터베이스 연결 컨텍스트 매니저"""
        conn = sqlite3.connect(self.db_path)
        conn.row_factory = sqlite3.Row  # 딕셔너리 형태로 결과 반환
        try:
            yield conn
            conn.commit()
        except Exception:
            conn.rollback()
            raise
        finally:
            conn.close()
    
    def insert_trade(self, trade_data: Dict[str, Any]) -> int:
        """거래 데이터 삽입 - 배치 처리 지원"""
        with self._get_connection() as conn:
            cursor = conn.execute("""
                INSERT INTO trades (symbol, side, quantity, price, timestamp, order_id)
                VALUES (?, ?, ?, ?, ?, ?)
            """, (
                trade_data['symbol'],
                trade_data['side'],
                trade_data['quantity'],
                trade_data['price'],
                trade_data['timestamp'],
                trade_data['order_id']
            ))
            return cursor.lastrowid
    
    def insert_trades_batch(self, trades_data: List[Dict[str, Any]]) -> None:
        """거래 데이터 배치 삽입 - 성능 최적화"""
        with self._get_connection() as conn:
            conn.executemany("""
                INSERT INTO trades (symbol, side, quantity, price, timestamp, order_id)
                VALUES (?, ?, ?, ?, ?, ?)
            """, [
                (
                    trade['symbol'],
                    trade['side'],
                    trade['quantity'],
                    trade['price'],
                    trade['timestamp'],
                    trade['order_id']
                )
                for trade in trades_data
            ])
    
    def get_trades_by_symbol(self, symbol: str, limit: int = 100) -> List[Dict[str, Any]]:
        """심볼별 거래 조회 - 인덱스 활용"""
        with self._get_connection() as conn:
            cursor = conn.execute("""
                SELECT * FROM trades 
                WHERE symbol = ? 
                ORDER BY timestamp DESC 
                LIMIT ?
            """, (symbol, limit))
            
            return [dict(row) for row in cursor.fetchall()]
    
    def get_trades_in_period(self, symbol: str, start_time: int, end_time: int) -> List[Dict[str, Any]]:
        """기간별 거래 조회 - 복합 인덱스 활용"""
        with self._get_connection() as conn:
            cursor = conn.execute("""
                SELECT * FROM trades 
                WHERE symbol = ? AND timestamp BETWEEN ? AND ?
                ORDER BY timestamp ASC
            """, (symbol, start_time, end_time))
            
            return [dict(row) for row in cursor.fetchall()]
```

---

## 🧪 8. 테스트 작성 가이드

### 8.1 단위 테스트

**테스트 구조 및 네이밍**
```python
import pytest
from unittest.mock import Mock, patch, AsyncMock
from datetime import datetime, timedelta

class TestTradingEngine:
    """거래 엔진 테스트 클래스"""
    
    @pytest.fixture
    def mock_market_data(self):
        """모의 시장 데이터 픽스처"""
        return MarketData(
            symbol="BTCUSDT",
            price=50000.0,
            volume=1000.0,
            timestamp=int(datetime.utcnow().timestamp())
        )
    
    @pytest.fixture
    def trading_engine(self):
        """거래 엔진 픽스처"""
        config = TradingConfig(
            max_positions=5,
            default_quantity=0.1,
            risk_percentage=0.02
        )
        return TradingEngine(config)
    
    def test_should_generate_buy_signal_when_price_above_moving_average(self, trading_engine, mock_market_data):
        """이동평균 위에서 매수 신호 생성 테스트"""
        # Given
        ma_condition = MovingAverageCondition(period=20, condition_type="close_above")
        trading_engine.add_entry_condition(ma_condition)
        
        # 이동평균보다 높은 가격 설정
        mock_market_data = mock_market_data._replace(price=51000.0)
        
        with patch.object(ma_condition, '_calculate_moving_average', return_value=50000.0):
            # When
            signals = trading_engine.evaluate_entry_signals(mock_market_data)
            
            # Then
            assert len(signals) == 1
            assert signals[0].signal_type == "BUY"
            assert signals[0].price == 51000.0
            assert signals[0].confidence > 0.7
    
    def test_should_not_generate_signal_when_condition_inactive(self, trading_engine, mock_market_data):
        """비활성 조건에서 신호 미생성 테스트"""
        # Given
        ma_condition = MovingAverageCondition(period=20, condition_type="close_above")
        ma_condition.deactivate()  # 조건 비활성화
        trading_engine.add_entry_condition(ma_condition)
        
        # When
        signals = trading_engine.evaluate_entry_signals(mock_market_data)
        
        # Then
        assert len(signals) == 0
    
    @pytest.mark.asyncio
    async def test_should_handle_api_error_gracefully(self, trading_engine):
        """API 오류 처리 테스트"""
        # Given
        order = Order("BTCUSDT", "BUY", 0.1, "MARKET")
        
        with patch.object(trading_engine.order_executor, 'execute_order') as mock_execute:
            mock_execute.side_effect = BinanceAPIError("Insufficient balance", -2010, "Account has insufficient balance")
            
            # When & Then
            with pytest.raises(InsufficientBalanceError):
                await trading_engine.execute_order(order)
    
    def test_should_calculate_position_size_correctly(self, trading_engine):
        """포지션 크기 계산 테스트"""
        # Given
        account_balance = 10000.0
        risk_percentage = 0.02  # 2%
        entry_price = 50000.0
        stop_loss_price = 49000.0
        
        # When
        position_size = trading_engine.calculate_position_size(
            account_balance, risk_percentage, entry_price, stop_loss_price
        )
        
        # Then
        expected_risk_amount = account_balance * risk_percentage  # 200
        expected_loss_per_unit = entry_price - stop_loss_price  # 1000
        expected_position_size = expected_risk_amount / expected_loss_per_unit  # 0.2
        
        assert abs(position_size - expected_position_size) < 0.001

class TestRiskManager:
    """리스크 관리자 테스트"""
    
    @pytest.fixture
    def risk_manager(self):
        """리스크 관리자 픽스처"""
        config = RiskConfig(
            max_positions=3,
            max_risk_per_trade=0.02,
            max_total_risk=0.06,
            max_drawdown=0.10
        )
        return RiskManager(config)
    
    def test_should_reject_order_when_max_positions_exceeded(self, risk_manager):
        """최대 포지션 수 초과 시 주문 거부 테스트"""
        # Given - 이미 3개 포지션 존재
        existing_positions = [
            Position("BTCUSDT", "BUY", 0.1, 50000),
            Position("ETHUSDT", "BUY", 1.0, 3000),
            Position("ADAUSDT", "BUY", 1000, 1.0)
        ]
        
        for position in existing_positions:
            risk_manager.add_position(position)
        
        new_order = Order("DOTUSDT", "BUY", 100, "MARKET")
        
        # When
        result = risk_manager.validate_order(new_order)
        
        # Then
        assert not result.is_valid
        assert "maximum positions" in result.error_message.lower()
    
    def test_should_allow_closing_order_when_max_positions_exceeded(self, risk_manager):
        """최대 포지션 수 초과 상황에서 청산 주문 허용 테스트"""
        # Given - 이미 3개 포지션 존재
        existing_positions = [
            Position("BTCUSDT", "BUY", 0.1, 50000),
            Position("ETHUSDT", "BUY", 1.0, 3000),
            Position("ADAUSDT", "BUY", 1000, 1.0)
        ]
        
        for position in existing_positions:
            risk_manager.add_position(position)
        
        # 기존 포지션 청산 주문
        closing_order = Order("BTCUSDT", "SELL", 0.1, "MARKET", reduce_only=True)
        
        # When
        result = risk_manager.validate_order(closing_order)
        
        # Then
        assert result.is_valid
```

### 8.2 통합 테스트

**실제 시나리오 테스트**
```python
@pytest.mark.integration
class TestTradingSystemIntegration:
    """거래 시스템 통합 테스트"""
    
    @pytest.fixture
    async def trading_system(self):
        """통합 테스트용 거래 시스템"""
        # 테스트용 설정
        config = TradingConfig(
            api_key="test_key",
            api_secret="test_secret",
            testnet=True,  # 테스트넷 사용
            max_positions=3
        )
        
        system = TradingSystem(config)
        await system.initialize()
        
        yield system
        
        await system.shutdown()
    
    @pytest.mark.asyncio
    async def test_complete_trading_cycle(self, trading_system):
        """완전한 거래 사이클 테스트"""
        # Given
        symbol = "BTCUSDT"
        
        # 1. 시장 데이터 수신 확인
        market_data = await trading_system.get_market_data(symbol)
        assert market_data is not None
        assert market_data.symbol == symbol
        
        # 2. 진입 신호 생성
        signals = trading_system.evaluate_entry_signals(market_data)
        
        if signals:
            signal = signals[0]
            
            # 3. 주문 실행
            order_result = await trading_system.execute_order(signal)
            assert order_result.status == "FILLED"
            
            # 4. 포지션 확인
            positions = trading_system.get_active_positions()
            assert len(positions) > 0
            
            position = next(p for p in positions if p.symbol == symbol)
            assert position.side == signal.signal_type
            
            # 5. 청산 신호 대기 (시뮬레이션)
            # 실제로는 시간이 걸리므로 모의 데이터 사용
            exit_price = market_data.price * 1.02 if signal.signal_type == "BUY" else market_data.price * 0.98
            exit_signal = Signal("SELL" if signal.signal_type == "BUY" else "BUY", exit_price, 0.9)
            
            # 6. 청산 실행
            exit_result = await trading_system.execute_order(exit_signal)
            assert exit_result.status == "FILLED"
            
            # 7. 포지션 정리 확인
            updated_positions = trading_system.get_active_positions()
            remaining_position = next((p for p in updated_positions if p.symbol == symbol), None)
            assert remaining_position is None or remaining_position.quantity == 0
    
    @pytest.mark.asyncio
    async def test_risk_management_integration(self, trading_system):
        """리스크 관리 통합 테스트"""
        # Given - 계정 잔고 조회
        account_info = await trading_system.get_account_info()
        initial_balance = account_info.total_balance
        
        # 큰 포지션 주문 시도 (리스크 한도 초과)
        large_quantity = initial_balance * 10  # 잔고의 10배
        large_order = Order("BTCUSDT", "BUY", large_quantity, "MARKET")
        
        # When & Then
        with pytest.raises(RiskLimitExceededError):
            await trading_system.execute_order_from_params(large_order)
    
    @pytest.mark.asyncio
    async def test_api_error_recovery(self, trading_system):
        """API 오류 복구 테스트"""
        # Given - API 연결 강제 종료
        await trading_system.api_connector.disconnect()
        
        # When - 시장 데이터 요청 (재연결 시도)
        market_data = await trading_system.get_market_data("BTCUSDT")
        
        # Then - 재연결 후 정상 데이터 수신
        assert market_data is not None
        assert trading_system.api_connector.is_connected()
```

### 8.3 성능 테스트

**벤치마크 및 부하 테스트**
```python
import time
import asyncio
from concurrent.futures import ThreadPoolExecutor

@pytest.mark.performance
class TestPerformance:
    """성능 테스트"""
    
    def test_signal_calculation_performance(self, benchmark):
        """신호 계산 성능 테스트"""
        # Given
        trading_engine = TradingEngine(TradingConfig())
        market_data = self._generate_market_data(1000)  # 1000개 데이터 포인트
        
        # When & Then
        result = benchmark(trading_engine.evaluate_entry_signals, market_data)
        
        # 성능 기준: 10ms 이하
        assert benchmark.stats['mean'] < 0.01
    
    @pytest.mark.asyncio
    async def test_concurrent_order_processing(self):
        """동시 주문 처리 성능 테스트"""
        trading_system = TradingSystem(TradingConfig())
        
        # 100개 동시 주문 생성
        orders = [
            Order(f"BTC{i}USDT", "BUY", 0.001, "MARKET")
            for i in range(100)
        ]
        
        start_time = time.time()
        
        # 동시 실행
        tasks = [trading_system.execute_order_simulation(order) for order in orders]
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        end_time = time.time()
        execution_time = end_time - start_time
        
        # 성능 기준: 100개 주문을 5초 내에 처리
        assert execution_time < 5.0
        
        # 성공률 확인
        successful_orders = [r for r in results if not isinstance(r, Exception)]
        success_rate = len(successful_orders) / len(orders)
        assert success_rate > 0.95  # 95% 이상 성공률
    
    def test_memory_usage_under_load(self):
        """부하 상황에서 메모리 사용량 테스트"""
        import psutil
        import gc
        
        process = psutil.Process()
        initial_memory = process.memory_info().rss / 1024 / 1024  # MB
        
        trading_engine = TradingEngine(TradingConfig())
        
        # 대량 데이터 처리
        for i in range(10000):
            market_data = MarketData(f"SYMBOL{i}", 50000.0, 1000.0, int(time.time()))
            signals = trading_engine.evaluate_entry_signals(market_data)
        
        gc.collect()  # 가비지 컬렉션 강제 실행
        
        final_memory = process.memory_info().rss / 1024 / 1024  # MB
        memory_increase = final_memory - initial_memory
        
        # 메모리 증가량이 100MB 이하여야 함
        assert memory_increase < 100
```

---

## 📚 9. 문서화 표준

### 9.1 독스트링 작성

**Google 스타일 독스트링**
```python
def calculate_compound_interest(principal: float, rate: float, time: int, compound_frequency: int = 1) -> float:
    """
    복리 이자를 계산합니다.
    
    이 함수는 주어진 원금, 이율, 기간을 바탕으로 복리 이자를 계산합니다.
    복리 계산 공식: A = P(1 + r/n)^(nt)
    
    Args:
        principal (float): 원금 (양수여야 함)
        rate (float): 연이율 (소수점 형태, 예: 0.05 = 5%)
        time (int): 투자 기간 (년 단위, 양수여야 함)
        compound_frequency (int, optional): 연간 복리 계산 횟수. 기본값은 1 (연 1회)
    
    Returns:
        float: 복리 이자가 적용된 최종 금액
    
    Raises:
        ValueError: principal, rate, time 중 하나라도 음수인 경우
        TypeError: 입력 매개변수의 타입이 올바르지 않은 경우
    
    Example:
        >>> calculate_compound_interest(1000, 0.05, 10)
        1628.8946267774416
        
        >>> calculate_compound_interest(1000, 0.05, 10, 12)  # 월복리
        1643.6194958854733
    
    Note:
        - 이 함수는 세금이나 수수료를 고려하지 않습니다
        - 실제 투자 수익률은 시장 상황에 따라 달라질 수 있습니다
    
    See Also:
        calculate_simple_interest: 단리 이자 계산
        calculate_present_value: 현재가치 계산
    """
    if principal < 0:
        raise ValueError("Principal must be non-negative")
    if rate < 0:
        raise ValueError("Rate must be non-negative")
    if time < 0:
        raise ValueError("Time must be non-negative")
    if compound_frequency <= 0:
        raise ValueError("Compound frequency must be positive")
    
    return principal * (1 + rate / compound_frequency) ** (compound_frequency * time)
```

### 9.2 클래스 문서화

**포괄적인 클래스 문서화**
```python
class TradingEngine:
    """
    암호화폐 자동매매 거래 엔진
    
    이 클래스는 다양한 진입 조건과 청산 조건을 관리하며, 실시간 시장 데이터를
    기반으로 거래 신호를 생성하고 주문을 실행하는 핵심 엔진입니다.
    
    주요 기능:
        - 5가지 진입 조건 지원 (이동평균, Price Channel, 호가감지, 틱기반, 캔들상태)
        - 4가지 청산 조건 지원 (PCS, 트레일링, 호가청산, PC본절)
        - 실시간 리스크 관리
        - 다중 거래소 지원 (바이낸스, 바이비트)
    
    Attributes:
        config (TradingConfig): 거래 엔진 설정
        entry_conditions (List[EntryCondition]): 활성화된 진입 조건 목록
        exit_conditions (List[ExitCondition]): 활성화된 청산 조건 목록
        position_manager (PositionManager): 포지션 관리자
        risk_manager (RiskManager): 리스크 관리자
        api_connector (APIConnector): API 연결자
        is_running (bool): 엔진 실행 상태
    
    Example:
        기본 사용법:
        
        >>> config = TradingConfig(max_positions=5, risk_percentage=0.02)
        >>> engine = TradingEngine(config)
        >>> 
        >>> # 진입 조건 추가
        >>> ma_condition = MovingAverageCondition(period=20, condition_type="close_above")
        >>> engine.add_entry_condition(ma_condition)
        >>> 
        >>> # 청산 조건 추가
        >>> pcs_condition = PCSExitCondition(stages=[1, 2, 3])
        >>> engine.add_exit_condition(pcs_condition)
        >>> 
        >>> # 거래 시작
        >>> await engine.start()
        >>> 
        >>> # 수동 신호 평가
        >>> market_data = await engine.get_market_data("BTCUSDT")
        >>> signals = engine.evaluate_entry_signals(market_data)
        >>> 
        >>> if signals:
        ...     result = await engine.execute_order(signals[0])
        ...     print(f"Order executed: {result.order_id}")
    
    Thread Safety:
        이 클래스는 스레드 안전하지 않습니다. 멀티스레드 환경에서 사용할 때는
        적절한 동기화 메커니즘을 구현해야 합니다.
    
    Performance:
        - 신호 평가 시간: 평균 5ms (1000개 데이터 포인트 기준)
        - 메모리 사용량: 약 50MB (기본 설정)
        - 동시 처리 가능 심볼: 최대 100개
    
    Version:
        1.0.0
    
    Author:
        Core Engine Agent
    
    See Also:
        TradingConfig: 거래 엔진 설정 클래스
        EntryCondition: 진입 조건 추상 클래스
        ExitCondition: 청산 조건 추상 클래스
        RiskManager: 리스크 관리 클래스
    """
    
    def __init__(self, config: TradingConfig):
        """
        거래 엔진을 초기화합니다.
        
        Args:
            config (TradingConfig): 거래 엔진 설정
                - max_positions: 최대 동시 포지션 수
                - risk_percentage: 거래당 리스크 비율
                - api_credentials: API 인증 정보
        
        Raises:
            ValueError: config가 유효하지 않은 경우
            APIError: API 연결 실패 시
        """
        self.config = config
        self.entry_conditions = []
        self.exit_conditions = []
        self.position_manager = PositionManager()
        self.risk_manager = RiskManager(config.risk_settings)
        self.api_connector = self._create_api_connector()
        self.is_running = False
        self._logger = create_logger(self.__class__.__name__)
    
    async def start(self) -> None:
        """
        거래 엔진을 시작합니다.
        
        이 메서드는 다음 작업을 수행합니다:
        1. API 연결 확인
        2. 계정 정보 조회
        3. 실시간 데이터 스트림 시작
        4. 거래 루프 시작
        
        Raises:
            APIError: API 연결 실패 시
            InsufficientBalanceError: 계정 잔고 부족 시
            TradingSystemError: 기타 시스템 오류
        
        Example:
            >>> engine = TradingEngine(config)
            >>> await engine.start()
            >>> print("Trading engine started successfully")
        """
        if self.is_running:
            self._logger.warning("Trading engine is already running")
            return
        
        try:
            # API 연결 확인
            await self.api_connector.connect()
            
            # 계정 정보 조회
            account_info = await self.api_connector.get_account_info()
            self._logger.info(f"Account balance: {account_info.total_balance}")
            
            # 실시간 데이터 스트림 시작
            await self._start_data_streams()
            
            # 거래 루프 시작
            self.is_running = True
            await self._run_trading_loop()
            
        except Exception as e:
            self._logger.error(f"Failed to start trading engine: {e}")
            await self.stop()
            raise
```

---

## 🔧 10. 코드 리뷰 체크리스트

### 10.1 기능성 검토

**✅ 기능 요구사항**
- [ ] 모든 요구사항이 구현되었는가?
- [ ] 엣지 케이스가 적절히 처리되는가?
- [ ] 오류 상황에 대한 처리가 구현되었는가?
- [ ] 입력 검증이 충분한가?

**✅ 비즈니스 로직**
- [ ] 거래 로직이 정확한가?
- [ ] 리스크 관리 규칙이 올바르게 적용되는가?
- [ ] 계산 공식이 정확한가?
- [ ] 시간 처리가 올바른가?

### 10.2 코드 품질 검토

**✅ 가독성**
- [ ] 변수명과 함수명이 명확한가?
- [ ] 코드 구조가 이해하기 쉬운가?
- [ ] 주석이 적절히 작성되었는가?
- [ ] 매직 넘버가 상수로 정의되었는가?

**✅ 유지보수성**
- [ ] 함수가 단일 책임을 가지는가?
- [ ] 코드 중복이 제거되었는가?
- [ ] 의존성이 적절히 관리되는가?
- [ ] 설정이 외부화되었는가?

### 10.3 성능 및 보안 검토

**✅ 성능**
- [ ] 알고리즘 복잡도가 적절한가?
- [ ] 메모리 사용량이 최적화되었는가?
- [ ] 데이터베이스 쿼리가 효율적인가?
- [ ] 캐싱이 적절히 활용되는가?

**✅ 보안**
- [ ] 민감한 정보가 암호화되었는가?
- [ ] 입력 검증이 충분한가?
- [ ] SQL 인젝션 등 보안 취약점이 없는가?
- [ ] 로그에 민감한 정보가 포함되지 않는가?

### 10.4 테스트 검토

**✅ 테스트 커버리지**
- [ ] 단위 테스트가 충분한가?
- [ ] 통합 테스트가 작성되었는가?
- [ ] 엣지 케이스 테스트가 포함되었는가?
- [ ] 성능 테스트가 필요한 부분에 작성되었는가?

---

## 📋 11. 결론

이 클린 코드 가이드라인은 **암호화폐 자동매매 시스템의 품질과 유지보수성을 보장**하기 위한 포괄적인 지침입니다.

### 11.1 핵심 원칙 요약

1. **가독성 우선**: 코드는 사람이 읽기 위해 작성
2. **단일 책임**: 각 모듈과 함수는 하나의 책임만 가짐
3. **의존성 주입**: 유연하고 테스트 가능한 설계
4. **오류 처리**: 예상 가능한 모든 오류 상황 대응
5. **성능 최적화**: 요구사항을 만족하는 최적의 성능
6. **보안 강화**: 민감한 정보와 시스템 보호
7. **테스트 우선**: 모든 코드는 테스트 가능하게 설계
8. **문서화**: 코드와 함께 업데이트되는 살아있는 문서

### 11.2 지속적 개선

- **코드 리뷰**: 모든 코드 변경사항에 대한 동료 검토
- **정적 분석**: SonarQube, Pylint 등 도구 활용
- **성능 모니터링**: 지속적인 성능 측정 및 최적화
- **보안 스캔**: 정기적인 보안 취약점 검사
- **리팩토링**: 기능 추가 시 기존 코드 개선

이 가이드라인을 따라 **세계 최고 수준의 자동매매 시스템**을 구축할 수 있습니다.

---

**문서 끝**

