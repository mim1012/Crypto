# 거래소별 API 메소드 조사 결과 (2025년 9월 19일 기준)

## 📋 개요

PRD에 명시된 암호화폐 자동매매 시스템 기능 구현을 위한 바이낸스(Binance)와 바이비트(Bybit) 거래소의 최신 API 메소드 호출 방식을 조사한 결과입니다.

---

## 🟡 바이낸스 선물 API (Binance Futures)

### 🔗 기본 정보
- **Base URL**: `https://fapi.binance.com`
- **Testnet URL**: `https://testnet.binancefuture.com`
- **API 버전**: v1
- **인증 방식**: HMAC SHA256 서명

### 🔐 인증 헤더
```http
X-MBX-APIKEY: {API_KEY}
```

### 📊 1. 주문 생성 (New Order)

#### HTTP 요청
```http
POST /fapi/v1/order
```

#### 필수 파라미터
```json
{
  "symbol": "BTCUSDT",           // 거래 심볼 (필수)
  "side": "BUY",                 // BUY 또는 SELL (필수)
  "type": "LIMIT",               // 주문 타입 (필수)
  "timeInForce": "GTC",          // 시간 조건
  "quantity": "0.001",           // 수량
  "price": "50000.00",           // 가격
  "timestamp": 1632150000000,    // 타임스탬프 (필수)
  "signature": "..."             // 서명 (필수)
}
```

#### 주문 타입별 추가 파라미터
| 주문 타입 | 추가 필수 파라미터 |
|-----------|-------------------|
| `LIMIT` | `timeInForce`, `quantity`, `price` |
| `MARKET` | `quantity` |
| `STOP/TAKE_PROFIT` | `quantity`, `price`, `stopPrice` |
| `STOP_MARKET/TAKE_PROFIT_MARKET` | `stopPrice` |
| `TRAILING_STOP_MARKET` | `callbackRate` |

#### 응답 예시
```json
{
  "orderId": 22542179,
  "symbol": "BTCUSDT",
  "status": "NEW",
  "clientOrderId": "testOrder",
  "price": "50000.00",
  "avgPrice": "0.00000",
  "origQty": "0.001",
  "executedQty": "0",
  "cumQty": "0",
  "cumQuote": "0",
  "timeInForce": "GTC",
  "type": "LIMIT",
  "reduceOnly": false,
  "closePosition": false,
  "side": "BUY",
  "positionSide": "BOTH",
  "stopPrice": "0",
  "workingType": "CONTRACT_PRICE",
  "priceProtect": false,
  "origType": "LIMIT",
  "updateTime": 1566818724722
}
```

### 📈 2. 시장 데이터 조회

#### 현재가 조회
```http
GET /fapi/v1/ticker/price?symbol=BTCUSDT
```

#### 응답 예시
```json
{
  "symbol": "BTCUSDT",
  "price": "50136.80000000"
}
```

#### 캔들 데이터 조회
```http
GET /fapi/v1/klines?symbol=BTCUSDT&interval=1m&limit=100
```

#### 응답 예시
```json
[
  [
    1499040000000,      // 시작 시간
    "0.01634790",       // 시가
    "0.80000000",       // 고가
    "0.01575800",       // 저가
    "0.01577100",       // 종가
    "148976.11427815",  // 거래량
    1499644799999,      // 종료 시간
    "2434.19055334",    // Quote asset volume
    308,                // 거래 횟수
    "1756.87402397",    // Taker buy base asset volume
    "28.46694368",      // Taker buy quote asset volume
    "17928899.62484339" // 무시
  ]
]
```

### 📊 3. 호가 데이터 조회
```http
GET /fapi/v1/depth?symbol=BTCUSDT&limit=20
```

#### 응답 예시
```json
{
  "lastUpdateId": 1027024,
  "E": 1589436922972,
  "T": 1589436922959,
  "bids": [
    ["4.00000000", "431.00000000"]
  ],
  "asks": [
    ["4.00000200", "12.00000000"]
  ]
}
```

### 💼 4. 포지션 정보 조회
```http
GET /fapi/v2/positionRisk
```

#### 응답 예시
```json
[
  {
    "symbol": "BTCUSDT",
    "positionAmt": "0.001",
    "entryPrice": "50000.0",
    "markPrice": "50136.80000000",
    "unRealizedProfit": "0.13680000",
    "liquidationPrice": "0",
    "leverage": "10",
    "maxNotionalValue": "25000",
    "marginType": "isolated",
    "isolatedMargin": "0.00000000",
    "isAutoAddMargin": "false",
    "positionSide": "BOTH",
    "notional": "50.13680000",
    "isolatedWallet": "0",
    "updateTime": 1625474304765
  }
]
```

---

## 🟠 바이비트 API (Bybit V5)

### 🔗 기본 정보
- **Base URL**: `https://api.bybit.com`
- **Testnet URL**: `https://api-testnet.bybit.com`
- **API 버전**: v5
- **인증 방식**: HMAC SHA256 서명

### 🔐 인증 헤더
```http
X-BAPI-API-KEY: {API_KEY}
X-BAPI-TIMESTAMP: {timestamp}
X-BAPI-SIGN: {signature}
X-BAPI-RECV-WINDOW: 5000
```

### 📊 1. 주문 생성 (Place Order)

#### HTTP 요청
```http
POST /v5/order/create
```

#### 필수 파라미터
```json
{
  "category": "linear",          // 상품 타입 (필수)
  "symbol": "BTCUSDT",          // 거래 심볼 (필수)
  "side": "Buy",                // Buy 또는 Sell (필수)
  "orderType": "Limit",         // 주문 타입 (필수)
  "qty": "0.001",               // 수량 (필수)
  "price": "50000.00"           // 가격
}
```

#### 카테고리별 지원 상품
| 카테고리 | 설명 |
|----------|------|
| `linear` | USDT 무기한 선물 |
| `inverse` | 역방향 선물 |
| `spot` | 현물 거래 |
| `option` | 옵션 거래 |

#### 응답 예시
```json
{
  "retCode": 0,
  "retMsg": "OK",
  "result": {
    "orderId": "1321003749386327552",
    "orderLinkId": "spot-test-postonly"
  },
  "retExtInfo": {},
  "time": 1672211918471
}
```

### 📈 2. 시장 데이터 조회

#### 현재가 조회
```http
GET /v5/market/tickers?category=linear&symbol=BTCUSDT
```

#### 응답 예시
```json
{
  "retCode": 0,
  "retMsg": "OK",
  "result": {
    "category": "linear",
    "list": [
      {
        "symbol": "BTCUSDT",
        "lastPrice": "50136.80",
        "indexPrice": "50142.33",
        "markPrice": "50139.54",
        "prevPrice24h": "49500.00",
        "price24hPcnt": "0.0129",
        "highPrice24h": "50800.00",
        "lowPrice24h": "49200.00",
        "prevPrice1h": "50000.00",
        "openInterest": "15678.123",
        "openInterestValue": "785291234.12",
        "turnover24h": "2387584.123456",
        "volume24h": "47.123",
        "fundingRate": "0.0001",
        "nextFundingTime": "1672214400000",
        "predictedDeliveryPrice": "",
        "basisRate": "",
        "deliveryFeeRate": "",
        "deliveryTime": "0",
        "ask1Size": "1.123",
        "bid1Price": "50135.00",
        "ask1Price": "50140.00",
        "bid1Size": "0.456"
      }
    ]
  },
  "retExtInfo": {},
  "time": 1672211918471
}
```

#### 캔들 데이터 조회
```http
GET /v5/market/kline?category=linear&symbol=BTCUSDT&interval=1&limit=100
```

#### 응답 예시
```json
{
  "retCode": 0,
  "retMsg": "OK",
  "result": {
    "symbol": "BTCUSDT",
    "category": "linear",
    "list": [
      [
        "1672214400000",  // 시작 시간
        "50000.00",       // 시가
        "50200.00",       // 고가
        "49800.00",       // 저가
        "50136.80",       // 종가
        "47.123",         // 거래량
        "2387584.123456"  // 거래 금액
      ]
    ]
  },
  "retExtInfo": {},
  "time": 1672211918471
}
```

### 📊 3. 호가 데이터 조회
```http
GET /v5/market/orderbook?category=linear&symbol=BTCUSDT&limit=25
```

#### 응답 예시
```json
{
  "retCode": 0,
  "retMsg": "OK",
  "result": {
    "s": "BTCUSDT",
    "a": [
      ["50140.00", "0.123"],
      ["50141.00", "0.456"]
    ],
    "b": [
      ["50135.00", "0.789"],
      ["50134.00", "1.234"]
    ],
    "ts": 1672211918471,
    "u": 18521
  },
  "retExtInfo": {},
  "time": 1672211918471
}
```

### 💼 4. 포지션 정보 조회
```http
GET /v5/position/list?category=linear&symbol=BTCUSDT
```

#### 응답 예시
```json
{
  "retCode": 0,
  "retMsg": "OK",
  "result": {
    "list": [
      {
        "positionIdx": 0,
        "riskId": 1,
        "riskLimitValue": "200000",
        "symbol": "BTCUSDT",
        "side": "Buy",
        "size": "0.001",
        "avgPrice": "50000.00",
        "positionValue": "50.00",
        "tradeMode": 0,
        "positionStatus": "Normal",
        "autoAddMargin": 0,
        "adlRankIndicator": 2,
        "leverage": "10",
        "positionBalance": "5.00",
        "markPrice": "50136.80",
        "liqPrice": "45000.00",
        "bustPrice": "44500.00",
        "positionMM": "0.25",
        "positionIM": "5.00",
        "tpslMode": "Full",
        "takeProfit": "55000.00",
        "stopLoss": "45000.00",
        "trailingStop": "0",
        "unrealisedPnl": "0.1368",
        "cumRealisedPnl": "0",
        "seq": 5723621632,
        "isReduceOnly": false,
        "mmrSysUpdatedTime": "",
        "leverageSysUpdatedTime": "",
        "createdTime": "1672211918471",
        "updatedTime": "1672211918471"
      }
    ],
    "nextPageCursor": "",
    "category": "linear"
  },
  "retExtInfo": {},
  "time": 1672211918471
}
```

---

## 🔧 PRD 기능별 API 매핑

### 📊 1. 이동평균선 조건 구현

#### 필요한 API 호출
```python
# 바이낸스
def get_moving_average_data(symbol, interval="1m", limit=4):
    url = f"https://fapi.binance.com/fapi/v1/klines"
    params = {
        "symbol": symbol,
        "interval": interval,
        "limit": limit
    }
    response = requests.get(url, params=params)
    return response.json()

# 바이비트
def get_moving_average_data_bybit(symbol, interval="1", limit=4):
    url = f"https://api.bybit.com/v5/market/kline"
    params = {
        "category": "linear",
        "symbol": symbol,
        "interval": interval,
        "limit": limit
    }
    response = requests.get(url, params=params)
    return response.json()
```

### 📈 2. Price Channel 조건 구현

#### 필요한 API 호출
```python
# 바이낸스 - 20일 고가/저가 데이터
def get_price_channel_data(symbol, interval="1d", limit=20):
    url = f"https://fapi.binance.com/fapi/v1/klines"
    params = {
        "symbol": symbol,
        "interval": interval,
        "limit": limit
    }
    response = requests.get(url, params=params)
    klines = response.json()
    
    highs = [float(kline[2]) for kline in klines]  # 고가
    lows = [float(kline[3]) for kline in klines]   # 저가
    
    upper_channel = max(highs)
    lower_channel = min(lows)
    middle_channel = (upper_channel + lower_channel) / 2
    
    return {
        "upper": upper_channel,
        "lower": lower_channel,
        "middle": middle_channel
    }
```

### 🔔 3. 호가 감시 조건 구현

#### 실시간 호가 데이터
```python
# 바이낸스 WebSocket
def binance_orderbook_stream(symbol):
    socket = f"wss://fstream.binance.com/ws/{symbol.lower()}@depth@100ms"
    # WebSocket 연결 및 실시간 호가 데이터 수신

# 바이비트 WebSocket
def bybit_orderbook_stream(symbol):
    socket = f"wss://stream.bybit.com/v5/public/linear"
    # WebSocket 연결 및 실시간 호가 데이터 수신
```

### 🕯️ 4. 캔들 상태 조건 구현

#### 실시간 캔들 데이터
```python
# 바이낸스 - 현재 진행중인 캔들
def get_current_candle(symbol):
    url = f"https://fapi.binance.com/fapi/v1/klines"
    params = {
        "symbol": symbol,
        "interval": "1m",
        "limit": 1
    }
    response = requests.get(url, params=params)
    candle = response.json()[0]
    
    open_price = float(candle[1])
    current_price = float(candle[4])
    
    return {
        "is_bullish": current_price > open_price,
        "is_bearish": current_price < open_price,
        "open": open_price,
        "current": current_price
    }
```

### ⚡ 5. 주문 실행 구현

#### 바이낸스 주문 생성
```python
def create_binance_order(symbol, side, quantity, price=None, order_type="MARKET"):
    url = "https://fapi.binance.com/fapi/v1/order"
    
    params = {
        "symbol": symbol,
        "side": side,
        "type": order_type,
        "quantity": quantity,
        "timestamp": int(time.time() * 1000)
    }
    
    if order_type == "LIMIT":
        params["price"] = price
        params["timeInForce"] = "GTC"
    
    # 서명 생성
    query_string = "&".join([f"{k}={v}" for k, v in params.items()])
    signature = hmac.new(
        SECRET_KEY.encode('utf-8'),
        query_string.encode('utf-8'),
        hashlib.sha256
    ).hexdigest()
    params["signature"] = signature
    
    headers = {"X-MBX-APIKEY": API_KEY}
    response = requests.post(url, params=params, headers=headers)
    return response.json()
```

#### 바이비트 주문 생성
```python
def create_bybit_order(symbol, side, quantity, price=None, order_type="Market"):
    url = "https://api.bybit.com/v5/order/create"
    timestamp = str(int(time.time() * 1000))
    
    data = {
        "category": "linear",
        "symbol": symbol,
        "side": side,
        "orderType": order_type,
        "qty": quantity
    }
    
    if order_type == "Limit":
        data["price"] = price
    
    # 서명 생성
    param_str = json.dumps(data, separators=(',', ':'))
    hash_payload = timestamp + API_KEY + "5000" + param_str
    signature = hmac.new(
        SECRET_KEY.encode('utf-8'),
        hash_payload.encode('utf-8'),
        hashlib.sha256
    ).hexdigest()
    
    headers = {
        "X-BAPI-API-KEY": API_KEY,
        "X-BAPI-TIMESTAMP": timestamp,
        "X-BAPI-SIGN": signature,
        "X-BAPI-RECV-WINDOW": "5000",
        "Content-Type": "application/json"
    }
    
    response = requests.post(url, json=data, headers=headers)
    return response.json()
```

---

## 🚨 주요 차이점 및 주의사항

### 🔄 API 구조 차이점

| 항목 | 바이낸스 | 바이비트 |
|------|----------|----------|
| **Base URL** | fapi.binance.com | api.bybit.com |
| **API 버전** | v1 | v5 |
| **인증 헤더** | X-MBX-APIKEY | X-BAPI-API-KEY |
| **서명 방식** | Query String | JSON Body |
| **주문 사이드** | BUY/SELL | Buy/Sell |
| **카테고리** | 없음 | linear/inverse/spot |

### ⚠️ 제한사항

#### 바이낸스 제한
- **주문 제한**: 10초당 1개, 1분당 1개
- **IP 제한**: 분당 2400 가중치
- **포지션 제한**: 심볼당 최대 200개 활성 주문

#### 바이비트 제한
- **주문 제한**: 심볼당 최대 500개 활성 주문
- **조건부 주문**: 심볼당 최대 10개
- **API 요청**: 분당 120회 (일반 사용자)

### 🔐 보안 고려사항

1. **API 키 관리**: 환경 변수 또는 암호화된 설정 파일 사용
2. **IP 화이트리스트**: 가능한 경우 IP 제한 설정
3. **권한 최소화**: 필요한 권한만 부여 (READ, TRADE)
4. **서명 검증**: 모든 요청에 올바른 서명 포함

---

## 📝 구현 권장사항

### 🏗️ 아키텍처 설계
1. **추상화 계층**: 거래소별 차이점을 추상화하는 인터페이스 구현
2. **에러 처리**: 네트워크 오류, API 제한, 잘못된 파라미터 등 처리
3. **재시도 로직**: 일시적 오류에 대한 지수 백오프 재시도
4. **로깅 시스템**: 모든 API 호출과 응답 로깅

### 🔄 실시간 데이터 처리
1. **WebSocket 연결**: 실시간 가격, 호가, 거래 데이터
2. **연결 관리**: 자동 재연결, 하트비트 처리
3. **데이터 버퍼링**: 일시적 연결 끊김 대비 데이터 버퍼
4. **스레드 안전성**: 멀티스레드 환경에서의 데이터 동기화

이 조사 결과를 바탕으로 PRD에 명시된 모든 기능을 안정적이고 효율적으로 구현할 수 있습니다.


---

## 🌐 WebSocket API 실시간 데이터 스트림

### 🟡 바이낸스 WebSocket 스트림

#### 🔗 기본 연결 정보
- **Base URL**: `wss://fstream.binance.com`
- **API WebSocket**: `wss://ws-fapi.binance.com/ws-fapi/v1`
- **Ping 주기**: 20초마다 ping 프레임 전송

#### 📊 주요 스트림 엔드포인트

##### 1. 실시간 가격 스트림
```javascript
// 개별 심볼 가격
wss://fstream.binance.com/ws/btcusdt@ticker

// 모든 심볼 가격
wss://fstream.binance.com/ws/!ticker@arr
```

##### 2. 캔들스틱 데이터 스트림
```javascript
// 1분봉 캔들
wss://fstream.binance.com/ws/btcusdt@kline_1m

// 5분봉 캔들
wss://fstream.binance.com/ws/btcusdt@kline_5m
```

##### 3. 호가 데이터 스트림
```javascript
// 실시간 호가 (100ms 업데이트)
wss://fstream.binance.com/ws/btcusdt@depth@100ms

// 부분 호가 (5단계)
wss://fstream.binance.com/ws/btcusdt@depth5@100ms
```

##### 4. 거래 데이터 스트림
```javascript
// 실시간 거래
wss://fstream.binance.com/ws/btcusdt@trade

// 집계 거래
wss://fstream.binance.com/ws/btcusdt@aggTrade
```

#### 📝 WebSocket 메시지 예시

##### 가격 티커 응답
```json
{
  "e": "24hrTicker",
  "E": 1672515782136,
  "s": "BTCUSDT",
  "p": "-0.0018",
  "P": "-0.0036",
  "w": "50123.45",
  "x": "50000.00",
  "c": "50136.80",
  "Q": "0.001",
  "b": "50135.00",
  "B": "0.123",
  "a": "50140.00",
  "A": "0.456",
  "o": "50154.80",
  "h": "50800.00",
  "l": "49200.00",
  "v": "47.123",
  "q": "2387584.123456",
  "O": 1672429382136,
  "C": 1672515782136,
  "F": 175142,
  "L": 175143,
  "n": 2
}
```

##### 캔들스틱 응답
```json
{
  "e": "kline",
  "E": 1672515782136,
  "s": "BTCUSDT",
  "k": {
    "t": 1672515780000,
    "T": 1672515839999,
    "s": "BTCUSDT",
    "i": "1m",
    "f": 175142,
    "L": 175143,
    "o": "50000.00",
    "c": "50136.80",
    "h": "50200.00",
    "l": "49800.00",
    "v": "0.123",
    "n": 2,
    "x": false,
    "q": "6168.456",
    "V": "0.056",
    "Q": "2804.123",
    "B": "0"
  }
}
```

### 🟠 바이비트 WebSocket 스트림

#### 🔗 기본 연결 정보
- **Public Stream**: `wss://stream.bybit.com/v5/public/linear`
- **Private Stream**: `wss://stream.bybit.com/v5/private`
- **Heartbeat**: 30초마다 ping 전송

#### 📊 주요 스트림 구독

##### 1. 실시간 가격 구독
```json
{
  "op": "subscribe",
  "args": [
    "tickers.BTCUSDT"
  ]
}
```

##### 2. 캔들스틱 데이터 구독
```json
{
  "op": "subscribe",
  "args": [
    "kline.1.BTCUSDT"
  ]
}
```

##### 3. 호가 데이터 구독
```json
{
  "op": "subscribe",
  "args": [
    "orderbook.1.BTCUSDT"
  ]
}
```

##### 4. 거래 데이터 구독
```json
{
  "op": "subscribe",
  "args": [
    "publicTrade.BTCUSDT"
  ]
}
```

#### 📝 WebSocket 메시지 예시

##### 가격 티커 응답
```json
{
  "topic": "tickers.BTCUSDT",
  "type": "snapshot",
  "data": {
    "symbol": "BTCUSDT",
    "tickDirection": "PlusTick",
    "price24hPcnt": "0.0129",
    "lastPrice": "50136.80",
    "prevPrice24h": "49500.00",
    "highPrice24h": "50800.00",
    "lowPrice24h": "49200.00",
    "prevPrice1h": "50000.00",
    "markPrice": "50139.54",
    "indexPrice": "50142.33",
    "openInterest": "15678.123",
    "openInterestValue": "785291234.12",
    "turnover24h": "2387584.123456",
    "volume24h": "47.123",
    "nextFundingTime": "1672214400000",
    "fundingRate": "0.0001",
    "bid1Price": "50135.00",
    "bid1Size": "0.456",
    "ask1Price": "50140.00",
    "ask1Size": "1.123"
  },
  "cs": 2588407624,
  "ts": 1672515782136
}
```

##### 캔들스틱 응답
```json
{
  "topic": "kline.1.BTCUSDT",
  "data": [
    {
      "start": 1672515780000,
      "end": 1672515839999,
      "interval": "1",
      "open": "50000.00",
      "close": "50136.80",
      "high": "50200.00",
      "low": "49800.00",
      "volume": "0.123",
      "turnover": "6168.456",
      "confirm": false,
      "timestamp": 1672515782136
    }
  ],
  "ts": 1672515782136
}
```

---

## 🔄 실시간 데이터 처리 구현 예시

### 🟡 바이낸스 WebSocket 클라이언트

```python
import websocket
import json
import threading

class BinanceWebSocketClient:
    def __init__(self, symbol="BTCUSDT"):
        self.symbol = symbol.lower()
        self.ws = None
        self.callbacks = {}
        
    def on_message(self, ws, message):
        try:
            data = json.loads(message)
            stream = data.get('stream', '')
            
            if 'ticker' in stream:
                self._handle_ticker(data['data'])
            elif 'kline' in stream:
                self._handle_kline(data['data'])
            elif 'depth' in stream:
                self._handle_depth(data['data'])
            elif 'trade' in stream:
                self._handle_trade(data['data'])
                
        except Exception as e:
            print(f"Error processing message: {e}")
    
    def on_error(self, ws, error):
        print(f"WebSocket error: {error}")
    
    def on_close(self, ws, close_status_code, close_msg):
        print("WebSocket connection closed")
    
    def on_open(self, ws):
        print("WebSocket connection opened")
        
        # 구독할 스트림들
        streams = [
            f"{self.symbol}@ticker",
            f"{self.symbol}@kline_1m",
            f"{self.symbol}@depth@100ms",
            f"{self.symbol}@trade"
        ]
        
        # 복합 스트림 구독
        subscribe_msg = {
            "method": "SUBSCRIBE",
            "params": streams,
            "id": 1
        }
        ws.send(json.dumps(subscribe_msg))
    
    def _handle_ticker(self, data):
        if 'ticker' in self.callbacks:
            self.callbacks['ticker'](data)
    
    def _handle_kline(self, data):
        if 'kline' in self.callbacks:
            self.callbacks['kline'](data['k'])
    
    def _handle_depth(self, data):
        if 'depth' in self.callbacks:
            self.callbacks['depth'](data)
    
    def _handle_trade(self, data):
        if 'trade' in self.callbacks:
            self.callbacks['trade'](data)
    
    def set_callback(self, event_type, callback):
        self.callbacks[event_type] = callback
    
    def start(self):
        websocket.enableTrace(True)
        self.ws = websocket.WebSocketApp(
            "wss://fstream.binance.com/ws/",
            on_message=self.on_message,
            on_error=self.on_error,
            on_close=self.on_close,
            on_open=self.on_open
        )
        
        # 별도 스레드에서 실행
        wst = threading.Thread(target=self.ws.run_forever)
        wst.daemon = True
        wst.start()
        return wst

# 사용 예시
def on_price_update(data):
    print(f"Price: {data['c']}, Volume: {data['v']}")

def on_candle_update(data):
    print(f"Candle: O:{data['o']} H:{data['h']} L:{data['l']} C:{data['c']}")

client = BinanceWebSocketClient("BTCUSDT")
client.set_callback('ticker', on_price_update)
client.set_callback('kline', on_candle_update)
client.start()
```

### 🟠 바이비트 WebSocket 클라이언트

```python
import websocket
import json
import threading
import time

class BybitWebSocketClient:
    def __init__(self, symbol="BTCUSDT"):
        self.symbol = symbol
        self.ws = None
        self.callbacks = {}
        self.ping_thread = None
        
    def on_message(self, ws, message):
        try:
            data = json.loads(message)
            
            if 'topic' in data:
                topic = data['topic']
                
                if 'tickers' in topic:
                    self._handle_ticker(data['data'])
                elif 'kline' in topic:
                    self._handle_kline(data['data'][0])
                elif 'orderbook' in topic:
                    self._handle_orderbook(data['data'])
                elif 'publicTrade' in topic:
                    self._handle_trade(data['data'][0])
            elif data.get('op') == 'pong':
                print("Received pong")
                
        except Exception as e:
            print(f"Error processing message: {e}")
    
    def on_error(self, ws, error):
        print(f"WebSocket error: {error}")
    
    def on_close(self, ws, close_status_code, close_msg):
        print("WebSocket connection closed")
        if self.ping_thread:
            self.ping_thread.join()
    
    def on_open(self, ws):
        print("WebSocket connection opened")
        
        # 구독 메시지
        subscribe_msg = {
            "op": "subscribe",
            "args": [
                f"tickers.{self.symbol}",
                f"kline.1.{self.symbol}",
                f"orderbook.1.{self.symbol}",
                f"publicTrade.{self.symbol}"
            ]
        }
        ws.send(json.dumps(subscribe_msg))
        
        # Ping 스레드 시작
        self.ping_thread = threading.Thread(target=self._ping_loop)
        self.ping_thread.daemon = True
        self.ping_thread.start()
    
    def _ping_loop(self):
        while self.ws and not self.ws.sock.closed:
            time.sleep(30)  # 30초마다 ping
            if self.ws and not self.ws.sock.closed:
                ping_msg = {"op": "ping"}
                self.ws.send(json.dumps(ping_msg))
    
    def _handle_ticker(self, data):
        if 'ticker' in self.callbacks:
            self.callbacks['ticker'](data)
    
    def _handle_kline(self, data):
        if 'kline' in self.callbacks:
            self.callbacks['kline'](data)
    
    def _handle_orderbook(self, data):
        if 'orderbook' in self.callbacks:
            self.callbacks['orderbook'](data)
    
    def _handle_trade(self, data):
        if 'trade' in self.callbacks:
            self.callbacks['trade'](data)
    
    def set_callback(self, event_type, callback):
        self.callbacks[event_type] = callback
    
    def start(self):
        websocket.enableTrace(True)
        self.ws = websocket.WebSocketApp(
            "wss://stream.bybit.com/v5/public/linear",
            on_message=self.on_message,
            on_error=self.on_error,
            on_close=self.on_close,
            on_open=self.on_open
        )
        
        # 별도 스레드에서 실행
        wst = threading.Thread(target=self.ws.run_forever)
        wst.daemon = True
        wst.start()
        return wst

# 사용 예시
def on_bybit_price_update(data):
    print(f"Bybit Price: {data['lastPrice']}, Volume: {data['volume24h']}")

def on_bybit_candle_update(data):
    print(f"Bybit Candle: O:{data['open']} H:{data['high']} L:{data['low']} C:{data['close']}")

client = BybitWebSocketClient("BTCUSDT")
client.set_callback('ticker', on_bybit_price_update)
client.set_callback('kline', on_bybit_candle_update)
client.start()
```

---

## 🔧 통합 실시간 데이터 관리자

```python
class RealTimeDataManager:
    def __init__(self):
        self.binance_client = None
        self.bybit_client = None
        self.data_cache = {
            'binance': {},
            'bybit': {}
        }
        self.callbacks = {}
    
    def start_binance_stream(self, symbol):
        self.binance_client = BinanceWebSocketClient(symbol)
        self.binance_client.set_callback('ticker', self._on_binance_ticker)
        self.binance_client.set_callback('kline', self._on_binance_kline)
        self.binance_client.set_callback('depth', self._on_binance_depth)
        self.binance_client.start()
    
    def start_bybit_stream(self, symbol):
        self.bybit_client = BybitWebSocketClient(symbol)
        self.bybit_client.set_callback('ticker', self._on_bybit_ticker)
        self.bybit_client.set_callback('kline', self._on_bybit_kline)
        self.bybit_client.set_callback('orderbook', self._on_bybit_orderbook)
        self.bybit_client.start()
    
    def _on_binance_ticker(self, data):
        self.data_cache['binance']['ticker'] = data
        self._trigger_callback('price_update', 'binance', data)
    
    def _on_binance_kline(self, data):
        self.data_cache['binance']['kline'] = data
        self._trigger_callback('candle_update', 'binance', data)
    
    def _on_binance_depth(self, data):
        self.data_cache['binance']['depth'] = data
        self._trigger_callback('orderbook_update', 'binance', data)
    
    def _on_bybit_ticker(self, data):
        self.data_cache['bybit']['ticker'] = data
        self._trigger_callback('price_update', 'bybit', data)
    
    def _on_bybit_kline(self, data):
        self.data_cache['bybit']['kline'] = data
        self._trigger_callback('candle_update', 'bybit', data)
    
    def _on_bybit_orderbook(self, data):
        self.data_cache['bybit']['orderbook'] = data
        self._trigger_callback('orderbook_update', 'bybit', data)
    
    def _trigger_callback(self, event_type, exchange, data):
        if event_type in self.callbacks:
            for callback in self.callbacks[event_type]:
                try:
                    callback(exchange, data)
                except Exception as e:
                    print(f"Callback error: {e}")
    
    def add_callback(self, event_type, callback):
        if event_type not in self.callbacks:
            self.callbacks[event_type] = []
        self.callbacks[event_type].append(callback)
    
    def get_current_price(self, exchange):
        if exchange == 'binance':
            ticker = self.data_cache['binance'].get('ticker')
            return float(ticker['c']) if ticker else None
        elif exchange == 'bybit':
            ticker = self.data_cache['bybit'].get('ticker')
            return float(ticker['lastPrice']) if ticker else None
    
    def get_current_candle(self, exchange):
        if exchange == 'binance':
            return self.data_cache['binance'].get('kline')
        elif exchange == 'bybit':
            return self.data_cache['bybit'].get('kline')

# 사용 예시
def on_price_change(exchange, data):
    if exchange == 'binance':
        price = data['c']
    else:  # bybit
        price = data['lastPrice']
    print(f"{exchange.upper()} 현재가: {price}")

def on_candle_change(exchange, data):
    if exchange == 'binance':
        candle_info = f"O:{data['o']} C:{data['c']}"
    else:  # bybit
        candle_info = f"O:{data['open']} C:{data['close']}"
    print(f"{exchange.upper()} 캔들: {candle_info}")

# 실시간 데이터 관리자 시작
manager = RealTimeDataManager()
manager.add_callback('price_update', on_price_change)
manager.add_callback('candle_update', on_candle_change)

manager.start_binance_stream("BTCUSDT")
manager.start_bybit_stream("BTCUSDT")
```

이 WebSocket 구현을 통해 PRD에 명시된 실시간 조건 감시 기능을 완벽하게 구현할 수 있습니다.

---

## 🧪 API 연결 테스트 스위트

### 🔧 테스트 환경 설정

```python
import requests
import hmac
import hashlib
import time
import json
import websocket
import threading
from datetime import datetime
import ssl

class APITester:
    def __init__(self):
        self.test_results = {}
        self.start_time = None
        self.end_time = None
    
    def run_all_tests(self):
        """모든 API 테스트 실행"""
        print("🚀 API 연결 테스트 시작...")
        self.start_time = time.time()
        
        # 바이낸스 테스트
        print("\n🟡 바이낸스 API 테스트")
        binance_results = self.test_binance_api()
        
        # 바이비트 테스트  
        print("\n🟠 바이비트 API 테스트")
        bybit_results = self.test_bybit_api()
        
        self.end_time = time.time()
        
        # 결과 출력
        self.print_test_results(binance_results, bybit_results)
        
        return {
            'binance': binance_results,
            'bybit': bybit_results,
            'total_time': self.end_time - self.start_time
        }
```

### 🟡 바이낸스 API 연결 테스트

```python
class BinanceAPITester:
    def __init__(self, api_key=None, secret_key=None):
        self.api_key = api_key
        self.secret_key = secret_key
        self.base_url = "https://fapi.binance.com"
        self.testnet_url = "https://testnet.binancefuture.com"
        
    def test_connection(self):
        """기본 연결 테스트"""
        try:
            start_time = time.time()
            response = requests.get(f"{self.base_url}/fapi/v1/ping", timeout=10)
            end_time = time.time()
            
            return {
                'status': 'SUCCESS' if response.status_code == 200 else 'FAILED',
                'response_time': round((end_time - start_time) * 1000, 2),
                'status_code': response.status_code,
                'error': None
            }
        except Exception as e:
            return {
                'status': 'FAILED',
                'response_time': None,
                'status_code': None,
                'error': str(e)
            }
    
    def test_server_time(self):
        """서버 시간 동기화 테스트"""
        try:
            start_time = time.time()
            response = requests.get(f"{self.base_url}/fapi/v1/time", timeout=10)
            end_time = time.time()
            
            if response.status_code == 200:
                server_time = response.json()['serverTime']
                local_time = int(time.time() * 1000)
                time_diff = abs(server_time - local_time)
                
                return {
                    'status': 'SUCCESS',
                    'response_time': round((end_time - start_time) * 1000, 2),
                    'server_time': server_time,
                    'local_time': local_time,
                    'time_diff_ms': time_diff,
                    'sync_status': 'GOOD' if time_diff < 1000 else 'WARNING',
                    'error': None
                }
            else:
                return {
                    'status': 'FAILED',
                    'response_time': round((end_time - start_time) * 1000, 2),
                    'error': f"HTTP {response.status_code}"
                }
        except Exception as e:
            return {
                'status': 'FAILED',
                'response_time': None,
                'error': str(e)
            }
    
    def test_exchange_info(self):
        """거래소 정보 조회 테스트"""
        try:
            start_time = time.time()
            response = requests.get(f"{self.base_url}/fapi/v1/exchangeInfo", timeout=15)
            end_time = time.time()
            
            if response.status_code == 200:
                data = response.json()
                symbols_count = len(data.get('symbols', []))
                
                return {
                    'status': 'SUCCESS',
                    'response_time': round((end_time - start_time) * 1000, 2),
                    'symbols_count': symbols_count,
                    'server_time': data.get('serverTime'),
                    'error': None
                }
            else:
                return {
                    'status': 'FAILED',
                    'response_time': round((end_time - start_time) * 1000, 2),
                    'error': f"HTTP {response.status_code}"
                }
        except Exception as e:
            return {
                'status': 'FAILED',
                'response_time': None,
                'error': str(e)
            }
    
    def test_market_data(self, symbol="BTCUSDT"):
        """시장 데이터 조회 테스트"""
        tests = {}
        
        # 현재가 테스트
        try:
            start_time = time.time()
            response = requests.get(f"{self.base_url}/fapi/v1/ticker/price", 
                                  params={'symbol': symbol}, timeout=10)
            end_time = time.time()
            
            if response.status_code == 200:
                data = response.json()
                tests['price'] = {
                    'status': 'SUCCESS',
                    'response_time': round((end_time - start_time) * 1000, 2),
                    'price': data.get('price'),
                    'error': None
                }
            else:
                tests['price'] = {
                    'status': 'FAILED',
                    'response_time': round((end_time - start_time) * 1000, 2),
                    'error': f"HTTP {response.status_code}"
                }
        except Exception as e:
            tests['price'] = {
                'status': 'FAILED',
                'response_time': None,
                'error': str(e)
            }
        
        # 캔들 데이터 테스트
        try:
            start_time = time.time()
            response = requests.get(f"{self.base_url}/fapi/v1/klines", 
                                  params={'symbol': symbol, 'interval': '1m', 'limit': 5}, 
                                  timeout=10)
            end_time = time.time()
            
            if response.status_code == 200:
                data = response.json()
                tests['klines'] = {
                    'status': 'SUCCESS',
                    'response_time': round((end_time - start_time) * 1000, 2),
                    'candles_count': len(data),
                    'latest_close': data[-1][4] if data else None,
                    'error': None
                }
            else:
                tests['klines'] = {
                    'status': 'FAILED',
                    'response_time': round((end_time - start_time) * 1000, 2),
                    'error': f"HTTP {response.status_code}"
                }
        except Exception as e:
            tests['klines'] = {
                'status': 'FAILED',
                'response_time': None,
                'error': str(e)
            }
        
        # 호가 데이터 테스트
        try:
            start_time = time.time()
            response = requests.get(f"{self.base_url}/fapi/v1/depth", 
                                  params={'symbol': symbol, 'limit': 10}, 
                                  timeout=10)
            end_time = time.time()
            
            if response.status_code == 200:
                data = response.json()
                tests['depth'] = {
                    'status': 'SUCCESS',
                    'response_time': round((end_time - start_time) * 1000, 2),
                    'bids_count': len(data.get('bids', [])),
                    'asks_count': len(data.get('asks', [])),
                    'best_bid': data['bids'][0][0] if data.get('bids') else None,
                    'best_ask': data['asks'][0][0] if data.get('asks') else None,
                    'error': None
                }
            else:
                tests['depth'] = {
                    'status': 'FAILED',
                    'response_time': round((end_time - start_time) * 1000, 2),
                    'error': f"HTTP {response.status_code}"
                }
        except Exception as e:
            tests['depth'] = {
                'status': 'FAILED',
                'response_time': None,
                'error': str(e)
            }
        
        return tests
    
    def test_authenticated_endpoints(self):
        """인증이 필요한 엔드포인트 테스트"""
        if not self.api_key or not self.secret_key:
            return {
                'account_info': {
                    'status': 'SKIPPED',
                    'error': 'API 키가 제공되지 않음'
                },
                'position_info': {
                    'status': 'SKIPPED', 
                    'error': 'API 키가 제공되지 않음'
                }
            }
        
        tests = {}
        
        # 계좌 정보 테스트
        try:
            timestamp = int(time.time() * 1000)
            query_string = f"timestamp={timestamp}"
            signature = hmac.new(
                self.secret_key.encode('utf-8'),
                query_string.encode('utf-8'),
                hashlib.sha256
            ).hexdigest()
            
            headers = {'X-MBX-APIKEY': self.api_key}
            params = {'timestamp': timestamp, 'signature': signature}
            
            start_time = time.time()
            response = requests.get(f"{self.base_url}/fapi/v2/account", 
                                  params=params, headers=headers, timeout=10)
            end_time = time.time()
            
            if response.status_code == 200:
                data = response.json()
                tests['account_info'] = {
                    'status': 'SUCCESS',
                    'response_time': round((end_time - start_time) * 1000, 2),
                    'total_wallet_balance': data.get('totalWalletBalance'),
                    'total_unrealized_pnl': data.get('totalUnrealizedProfit'),
                    'assets_count': len(data.get('assets', [])),
                    'error': None
                }
            else:
                tests['account_info'] = {
                    'status': 'FAILED',
                    'response_time': round((end_time - start_time) * 1000, 2),
                    'error': f"HTTP {response.status_code}: {response.text}"
                }
        except Exception as e:
            tests['account_info'] = {
                'status': 'FAILED',
                'response_time': None,
                'error': str(e)
            }
        
        # 포지션 정보 테스트
        try:
            timestamp = int(time.time() * 1000)
            query_string = f"timestamp={timestamp}"
            signature = hmac.new(
                self.secret_key.encode('utf-8'),
                query_string.encode('utf-8'),
                hashlib.sha256
            ).hexdigest()
            
            headers = {'X-MBX-APIKEY': self.api_key}
            params = {'timestamp': timestamp, 'signature': signature}
            
            start_time = time.time()
            response = requests.get(f"{self.base_url}/fapi/v2/positionRisk", 
                                  params=params, headers=headers, timeout=10)
            end_time = time.time()
            
            if response.status_code == 200:
                data = response.json()
                active_positions = [pos for pos in data if float(pos.get('positionAmt', 0)) != 0]
                
                tests['position_info'] = {
                    'status': 'SUCCESS',
                    'response_time': round((end_time - start_time) * 1000, 2),
                    'total_positions': len(data),
                    'active_positions': len(active_positions),
                    'error': None
                }
            else:
                tests['position_info'] = {
                    'status': 'FAILED',
                    'response_time': round((end_time - start_time) * 1000, 2),
                    'error': f"HTTP {response.status_code}: {response.text}"
                }
        except Exception as e:
            tests['position_info'] = {
                'status': 'FAILED',
                'response_time': None,
                'error': str(e)
            }
        
        return tests
    
    def test_websocket_connection(self, symbol="BTCUSDT"):
        """WebSocket 연결 테스트"""
        test_result = {
            'status': 'TESTING',
            'connection_time': None,
            'messages_received': 0,
            'error': None
        }
        
        def on_message(ws, message):
            test_result['messages_received'] += 1
            if test_result['messages_received'] >= 3:  # 3개 메시지 받으면 종료
                ws.close()
        
        def on_error(ws, error):
            test_result['status'] = 'FAILED'
            test_result['error'] = str(error)
        
        def on_close(ws, close_status_code, close_msg):
            if test_result['messages_received'] >= 3:
                test_result['status'] = 'SUCCESS'
        
        def on_open(ws):
            test_result['connection_time'] = time.time() - start_time
            # 가격 스트림 구독
            subscribe_msg = {
                "method": "SUBSCRIBE",
                "params": [f"{symbol.lower()}@ticker"],
                "id": 1
            }
            ws.send(json.dumps(subscribe_msg))
        
        try:
            start_time = time.time()
            ws = websocket.WebSocketApp(
                "wss://fstream.binance.com/ws/",
                on_message=on_message,
                on_error=on_error,
                on_close=on_close,
                on_open=on_open
            )
            
            # 5초 타임아웃으로 실행
            wst = threading.Thread(target=ws.run_forever, kwargs={'sslopt': {"cert_reqs": ssl.CERT_NONE}})
            wst.daemon = True
            wst.start()
            wst.join(timeout=5)
            
            if test_result['status'] == 'TESTING':
                test_result['status'] = 'TIMEOUT'
                test_result['error'] = '5초 내에 응답 없음'
            
        except Exception as e:
            test_result['status'] = 'FAILED'
            test_result['error'] = str(e)
        
        return test_result
```

### 🟠 바이비트 API 연결 테스트

```python
class BybitAPITester:
    def __init__(self, api_key=None, secret_key=None):
        self.api_key = api_key
        self.secret_key = secret_key
        self.base_url = "https://api.bybit.com"
        self.testnet_url = "https://api-testnet.bybit.com"
    
    def _generate_signature(self, timestamp, params_str=""):
        """바이비트 서명 생성"""
        param_str = str(timestamp) + self.api_key + "5000" + params_str
        return hmac.new(
            self.secret_key.encode('utf-8'),
            param_str.encode('utf-8'),
            hashlib.sha256
        ).hexdigest()
    
    def test_connection(self):
        """기본 연결 테스트"""
        try:
            start_time = time.time()
            response = requests.get(f"{self.base_url}/v5/market/time", timeout=10)
            end_time = time.time()
            
            if response.status_code == 200:
                data = response.json()
                return {
                    'status': 'SUCCESS' if data['retCode'] == 0 else 'FAILED',
                    'response_time': round((end_time - start_time) * 1000, 2),
                    'server_time': data['time'],
                    'ret_msg': data['retMsg'],
                    'error': None
                }
            else:
                return {
                    'status': 'FAILED',
                    'response_time': round((end_time - start_time) * 1000, 2),
                    'error': f"HTTP {response.status_code}"
                }
        except Exception as e:
            return {
                'status': 'FAILED',
                'response_time': None,
                'error': str(e)
            }
    
    def test_server_time(self):
        """서버 시간 동기화 테스트"""
        try:
            start_time = time.time()
            response = requests.get(f"{self.base_url}/v5/market/time", timeout=10)
            end_time = time.time()
            
            if response.status_code == 200:
                data = response.json()
                if data['retCode'] == 0:
                    server_time = int(data['time'])
                    local_time = int(time.time() * 1000)
                    time_diff = abs(server_time - local_time)
                    
                    return {
                        'status': 'SUCCESS',
                        'response_time': round((end_time - start_time) * 1000, 2),
                        'server_time': server_time,
                        'local_time': local_time,
                        'time_diff_ms': time_diff,
                        'sync_status': 'GOOD' if time_diff < 1000 else 'WARNING',
                        'error': None
                    }
                else:
                    return {
                        'status': 'FAILED',
                        'response_time': round((end_time - start_time) * 1000, 2),
                        'error': data['retMsg']
                    }
            else:
                return {
                    'status': 'FAILED',
                    'response_time': round((end_time - start_time) * 1000, 2),
                    'error': f"HTTP {response.status_code}"
                }
        except Exception as e:
            return {
                'status': 'FAILED',
                'response_time': None,
                'error': str(e)
            }
    
    def test_instruments_info(self, category="linear"):
        """거래 상품 정보 조회 테스트"""
        try:
            start_time = time.time()
            response = requests.get(f"{self.base_url}/v5/market/instruments-info", 
                                  params={'category': category}, timeout=15)
            end_time = time.time()
            
            if response.status_code == 200:
                data = response.json()
                if data['retCode'] == 0:
                    symbols_count = len(data['result']['list'])
                    
                    return {
                        'status': 'SUCCESS',
                        'response_time': round((end_time - start_time) * 1000, 2),
                        'category': category,
                        'symbols_count': symbols_count,
                        'error': None
                    }
                else:
                    return {
                        'status': 'FAILED',
                        'response_time': round((end_time - start_time) * 1000, 2),
                        'error': data['retMsg']
                    }
            else:
                return {
                    'status': 'FAILED',
                    'response_time': round((end_time - start_time) * 1000, 2),
                    'error': f"HTTP {response.status_code}"
                }
        except Exception as e:
            return {
                'status': 'FAILED',
                'response_time': None,
                'error': str(e)
            }
    
    def test_market_data(self, symbol="BTCUSDT", category="linear"):
        """시장 데이터 조회 테스트"""
        tests = {}
        
        # 현재가 테스트
        try:
            start_time = time.time()
            response = requests.get(f"{self.base_url}/v5/market/tickers", 
                                  params={'category': category, 'symbol': symbol}, 
                                  timeout=10)
            end_time = time.time()
            
            if response.status_code == 200:
                data = response.json()
                if data['retCode'] == 0 and data['result']['list']:
                    ticker = data['result']['list'][0]
                    tests['ticker'] = {
                        'status': 'SUCCESS',
                        'response_time': round((end_time - start_time) * 1000, 2),
                        'last_price': ticker.get('lastPrice'),
                        'mark_price': ticker.get('markPrice'),
                        'index_price': ticker.get('indexPrice'),
                        'volume_24h': ticker.get('volume24h'),
                        'error': None
                    }
                else:
                    tests['ticker'] = {
                        'status': 'FAILED',
                        'response_time': round((end_time - start_time) * 1000, 2),
                        'error': data['retMsg']
                    }
            else:
                tests['ticker'] = {
                    'status': 'FAILED',
                    'response_time': round((end_time - start_time) * 1000, 2),
                    'error': f"HTTP {response.status_code}"
                }
        except Exception as e:
            tests['ticker'] = {
                'status': 'FAILED',
                'response_time': None,
                'error': str(e)
            }
        
        # 캔들 데이터 테스트
        try:
            start_time = time.time()
            response = requests.get(f"{self.base_url}/v5/market/kline", 
                                  params={'category': category, 'symbol': symbol, 
                                         'interval': '1', 'limit': 5}, 
                                  timeout=10)
            end_time = time.time()
            
            if response.status_code == 200:
                data = response.json()
                if data['retCode'] == 0:
                    klines = data['result']['list']
                    tests['klines'] = {
                        'status': 'SUCCESS',
                        'response_time': round((end_time - start_time) * 1000, 2),
                        'candles_count': len(klines),
                        'latest_close': klines[0][4] if klines else None,
                        'error': None
                    }
                else:
                    tests['klines'] = {
                        'status': 'FAILED',
                        'response_time': round((end_time - start_time) * 1000, 2),
                        'error': data['retMsg']
                    }
            else:
                tests['klines'] = {
                    'status': 'FAILED',
                    'response_time': round((end_time - start_time) * 1000, 2),
                    'error': f"HTTP {response.status_code}"
                }
        except Exception as e:
            tests['klines'] = {
                'status': 'FAILED',
                'response_time': None,
                'error': str(e)
            }
        
        # 호가 데이터 테스트
        try:
            start_time = time.time()
            response = requests.get(f"{self.base_url}/v5/market/orderbook", 
                                  params={'category': category, 'symbol': symbol, 'limit': 25}, 
                                  timeout=10)
            end_time = time.time()
            
            if response.status_code == 200:
                data = response.json()
                if data['retCode'] == 0:
                    orderbook = data['result']
                    tests['orderbook'] = {
                        'status': 'SUCCESS',
                        'response_time': round((end_time - start_time) * 1000, 2),
                        'bids_count': len(orderbook.get('b', [])),
                        'asks_count': len(orderbook.get('a', [])),
                        'best_bid': orderbook['b'][0][0] if orderbook.get('b') else None,
                        'best_ask': orderbook['a'][0][0] if orderbook.get('a') else None,
                        'error': None
                    }
                else:
                    tests['orderbook'] = {
                        'status': 'FAILED',
                        'response_time': round((end_time - start_time) * 1000, 2),
                        'error': data['retMsg']
                    }
            else:
                tests['orderbook'] = {
                    'status': 'FAILED',
                    'response_time': round((end_time - start_time) * 1000, 2),
                    'error': f"HTTP {response.status_code}"
                }
        except Exception as e:
            tests['orderbook'] = {
                'status': 'FAILED',
                'response_time': None,
                'error': str(e)
            }
        
        return tests
    
    def test_authenticated_endpoints(self):
        """인증이 필요한 엔드포인트 테스트"""
        if not self.api_key or not self.secret_key:
            return {
                'wallet_balance': {
                    'status': 'SKIPPED',
                    'error': 'API 키가 제공되지 않음'
                },
                'position_info': {
                    'status': 'SKIPPED',
                    'error': 'API 키가 제공되지 않음'
                }
            }
        
        tests = {}
        
        # 지갑 잔고 테스트
        try:
            timestamp = str(int(time.time() * 1000))
            params = {"accountType": "UNIFIED"}
            params_str = json.dumps(params, separators=(',', ':'))
            signature = self._generate_signature(timestamp, params_str)
            
            headers = {
                'X-BAPI-API-KEY': self.api_key,
                'X-BAPI-TIMESTAMP': timestamp,
                'X-BAPI-SIGN': signature,
                'X-BAPI-RECV-WINDOW': '5000',
                'Content-Type': 'application/json'
            }
            
            start_time = time.time()
            response = requests.get(f"{self.base_url}/v5/account/wallet-balance", 
                                  params=params, headers=headers, timeout=10)
            end_time = time.time()
            
            if response.status_code == 200:
                data = response.json()
                if data['retCode'] == 0:
                    wallet_list = data['result']['list']
                    tests['wallet_balance'] = {
                        'status': 'SUCCESS',
                        'response_time': round((end_time - start_time) * 1000, 2),
                        'accounts_count': len(wallet_list),
                        'total_equity': wallet_list[0].get('totalEquity') if wallet_list else None,
                        'error': None
                    }
                else:
                    tests['wallet_balance'] = {
                        'status': 'FAILED',
                        'response_time': round((end_time - start_time) * 1000, 2),
                        'error': data['retMsg']
                    }
            else:
                tests['wallet_balance'] = {
                    'status': 'FAILED',
                    'response_time': round((end_time - start_time) * 1000, 2),
                    'error': f"HTTP {response.status_code}: {response.text}"
                }
        except Exception as e:
            tests['wallet_balance'] = {
                'status': 'FAILED',
                'response_time': None,
                'error': str(e)
            }
        
        # 포지션 정보 테스트
        try:
            timestamp = str(int(time.time() * 1000))
            params = {"category": "linear", "settleCoin": "USDT"}
            query_string = "&".join([f"{k}={v}" for k, v in params.items()])
            signature = self._generate_signature(timestamp, query_string)
            
            headers = {
                'X-BAPI-API-KEY': self.api_key,
                'X-BAPI-TIMESTAMP': timestamp,
                'X-BAPI-SIGN': signature,
                'X-BAPI-RECV-WINDOW': '5000'
            }
            
            start_time = time.time()
            response = requests.get(f"{self.base_url}/v5/position/list", 
                                  params=params, headers=headers, timeout=10)
            end_time = time.time()
            
            if response.status_code == 200:
                data = response.json()
                if data['retCode'] == 0:
                    positions = data['result']['list']
                    active_positions = [pos for pos in positions if float(pos.get('size', 0)) != 0]
                    
                    tests['position_info'] = {
                        'status': 'SUCCESS',
                        'response_time': round((end_time - start_time) * 1000, 2),
                        'total_positions': len(positions),
                        'active_positions': len(active_positions),
                        'error': None
                    }
                else:
                    tests['position_info'] = {
                        'status': 'FAILED',
                        'response_time': round((end_time - start_time) * 1000, 2),
                        'error': data['retMsg']
                    }
            else:
                tests['position_info'] = {
                    'status': 'FAILED',
                    'response_time': round((end_time - start_time) * 1000, 2),
                    'error': f"HTTP {response.status_code}: {response.text}"
                }
        except Exception as e:
            tests['position_info'] = {
                'status': 'FAILED',
                'response_time': None,
                'error': str(e)
            }
        
        return tests
    
    def test_websocket_connection(self, symbol="BTCUSDT"):
        """WebSocket 연결 테스트"""
        test_result = {
            'status': 'TESTING',
            'connection_time': None,
            'messages_received': 0,
            'error': None
        }
        
        def on_message(ws, message):
            test_result['messages_received'] += 1
            if test_result['messages_received'] >= 3:  # 3개 메시지 받으면 종료
                ws.close()
        
        def on_error(ws, error):
            test_result['status'] = 'FAILED'
            test_result['error'] = str(error)
        
        def on_close(ws, close_status_code, close_msg):
            if test_result['messages_received'] >= 3:
                test_result['status'] = 'SUCCESS'
        
        def on_open(ws):
            test_result['connection_time'] = time.time() - start_time
            # 가격 스트림 구독
            subscribe_msg = {
                "op": "subscribe",
                "args": [f"tickers.{symbol}"]
            }
            ws.send(json.dumps(subscribe_msg))
        
        try:
            start_time = time.time()
            ws = websocket.WebSocketApp(
                "wss://stream.bybit.com/v5/public/linear",
                on_message=on_message,
                on_error=on_error,
                on_close=on_close,
                on_open=on_open
            )
            
            # 5초 타임아웃으로 실행
            wst = threading.Thread(target=ws.run_forever, kwargs={'sslopt': {"cert_reqs": ssl.CERT_NONE}})
            wst.daemon = True
            wst.start()
            wst.join(timeout=5)
            
            if test_result['status'] == 'TESTING':
                test_result['status'] = 'TIMEOUT'
                test_result['error'] = '5초 내에 응답 없음'
            
        except Exception as e:
            test_result['status'] = 'FAILED'
            test_result['error'] = str(e)
        
        return test_result
```

### 🧪 통합 테스트 실행기

```python
class ComprehensiveAPITester:
    def __init__(self, binance_api_key=None, binance_secret=None, 
                 bybit_api_key=None, bybit_secret=None):
        self.binance_tester = BinanceAPITester(binance_api_key, binance_secret)
        self.bybit_tester = BybitAPITester(bybit_api_key, bybit_secret)
    
    def run_full_test_suite(self):
        """전체 테스트 스위트 실행"""
        print("🚀 암호화폐 거래소 API 연결 테스트 시작")
        print("=" * 60)
        
        results = {
            'timestamp': datetime.now().isoformat(),
            'binance': {},
            'bybit': {},
            'summary': {}
        }
        
        # 바이낸스 테스트
        print("\n🟡 바이낸스 API 테스트 실행 중...")
        results['binance'] = self._test_binance()
        
        # 바이비트 테스트
        print("\n🟠 바이비트 API 테스트 실행 중...")
        results['bybit'] = self._test_bybit()
        
        # 결과 요약
        results['summary'] = self._generate_summary(results)
        
        # 결과 출력
        self._print_results(results)
        
        return results
    
    def _test_binance(self):
        """바이낸스 전체 테스트"""
        tests = {}
        
        print("  📡 기본 연결 테스트...")
        tests['connection'] = self.binance_tester.test_connection()
        
        print("  🕐 서버 시간 동기화 테스트...")
        tests['server_time'] = self.binance_tester.test_server_time()
        
        print("  📊 거래소 정보 조회 테스트...")
        tests['exchange_info'] = self.binance_tester.test_exchange_info()
        
        print("  💹 시장 데이터 테스트...")
        tests['market_data'] = self.binance_tester.test_market_data()
        
        print("  🔐 인증 엔드포인트 테스트...")
        tests['authenticated'] = self.binance_tester.test_authenticated_endpoints()
        
        print("  🌐 WebSocket 연결 테스트...")
        tests['websocket'] = self.binance_tester.test_websocket_connection()
        
        return tests
    
    def _test_bybit(self):
        """바이비트 전체 테스트"""
        tests = {}
        
        print("  📡 기본 연결 테스트...")
        tests['connection'] = self.bybit_tester.test_connection()
        
        print("  🕐 서버 시간 동기화 테스트...")
        tests['server_time'] = self.bybit_tester.test_server_time()
        
        print("  📊 거래 상품 정보 테스트...")
        tests['instruments_info'] = self.bybit_tester.test_instruments_info()
        
        print("  💹 시장 데이터 테스트...")
        tests['market_data'] = self.bybit_tester.test_market_data()
        
        print("  🔐 인증 엔드포인트 테스트...")
        tests['authenticated'] = self.bybit_tester.test_authenticated_endpoints()
        
        print("  🌐 WebSocket 연결 테스트...")
        tests['websocket'] = self.bybit_tester.test_websocket_connection()
        
        return tests
    
    def _generate_summary(self, results):
        """테스트 결과 요약 생성"""
        summary = {
            'binance': {'total': 0, 'success': 0, 'failed': 0, 'skipped': 0},
            'bybit': {'total': 0, 'success': 0, 'failed': 0, 'skipped': 0},
            'overall': {'total': 0, 'success': 0, 'failed': 0, 'skipped': 0}
        }
        
        def count_results(test_data, exchange):
            for test_name, test_result in test_data.items():
                if isinstance(test_result, dict):
                    if 'status' in test_result:
                        summary[exchange]['total'] += 1
                        summary['overall']['total'] += 1
                        
                        status = test_result['status']
                        summary[exchange][status.lower()] += 1
                        summary['overall'][status.lower()] += 1
                    else:
                        # 중첩된 테스트 결과 처리
                        for sub_test_name, sub_test_result in test_result.items():
                            if isinstance(sub_test_result, dict) and 'status' in sub_test_result:
                                summary[exchange]['total'] += 1
                                summary['overall']['total'] += 1
                                
                                status = sub_test_result['status']
                                summary[exchange][status.lower()] += 1
                                summary['overall'][status.lower()] += 1
        
        count_results(results['binance'], 'binance')
        count_results(results['bybit'], 'bybit')
        
        return summary
    
    def _print_results(self, results):
        """테스트 결과 출력"""
        print("\n" + "=" * 60)
        print("📊 API 연결 테스트 결과 요약")
        print("=" * 60)
        
        summary = results['summary']
        
        # 전체 요약
        print(f"\n🎯 전체 테스트 결과:")
        print(f"  총 테스트: {summary['overall']['total']}개")
        print(f"  성공: {summary['overall']['success']}개 ✅")
        print(f"  실패: {summary['overall']['failed']}개 ❌")
        print(f"  건너뜀: {summary['overall']['skipped']}개 ⏭️")
        
        success_rate = (summary['overall']['success'] / summary['overall']['total'] * 100) if summary['overall']['total'] > 0 else 0
        print(f"  성공률: {success_rate:.1f}%")
        
        # 거래소별 요약
        for exchange in ['binance', 'bybit']:
            emoji = "🟡" if exchange == 'binance' else "🟠"
            name = exchange.upper()
            
            print(f"\n{emoji} {name} 테스트 결과:")
            print(f"  총 테스트: {summary[exchange]['total']}개")
            print(f"  성공: {summary[exchange]['success']}개 ✅")
            print(f"  실패: {summary[exchange]['failed']}개 ❌")
            print(f"  건너뜀: {summary[exchange]['skipped']}개 ⏭️")
            
            exchange_success_rate = (summary[exchange]['success'] / summary[exchange]['total'] * 100) if summary[exchange]['total'] > 0 else 0
            print(f"  성공률: {exchange_success_rate:.1f}%")
        
        # 상세 결과
        print("\n" + "=" * 60)
        print("📋 상세 테스트 결과")
        print("=" * 60)
        
        self._print_detailed_results("바이낸스", results['binance'])
        self._print_detailed_results("바이비트", results['bybit'])
    
    def _print_detailed_results(self, exchange_name, test_results):
        """상세 테스트 결과 출력"""
        print(f"\n🔍 {exchange_name} 상세 결과:")
        
        for test_category, test_data in test_results.items():
            print(f"\n  📂 {test_category.upper()}:")
            
            if isinstance(test_data, dict) and 'status' in test_data:
                self._print_single_test_result(test_data, "    ")
            else:
                for test_name, test_result in test_data.items():
                    if isinstance(test_result, dict) and 'status' in test_result:
                        print(f"    🔸 {test_name}:")
                        self._print_single_test_result(test_result, "      ")
    
    def _print_single_test_result(self, test_result, indent=""):
        """단일 테스트 결과 출력"""
        status = test_result.get('status', 'UNKNOWN')
        
        if status == 'SUCCESS':
            status_emoji = "✅"
        elif status == 'FAILED':
            status_emoji = "❌"
        elif status == 'SKIPPED':
            status_emoji = "⏭️"
        else:
            status_emoji = "❓"
        
        print(f"{indent}{status_emoji} 상태: {status}")
        
        if test_result.get('response_time'):
            print(f"{indent}⏱️  응답시간: {test_result['response_time']}ms")
        
        if test_result.get('error'):
            print(f"{indent}🚨 오류: {test_result['error']}")
        
        # 추가 정보 출력
        for key, value in test_result.items():
            if key not in ['status', 'response_time', 'error'] and value is not None:
                print(f"{indent}📊 {key}: {value}")

# 사용 예시
def main():
    """메인 테스트 실행 함수"""
    # API 키 설정 (실제 사용 시 환경 변수나 설정 파일에서 로드)
    BINANCE_API_KEY = "your_binance_api_key_here"  # 실제 키로 교체
    BINANCE_SECRET = "your_binance_secret_here"    # 실제 시크릿으로 교체
    BYBIT_API_KEY = "your_bybit_api_key_here"      # 실제 키로 교체
    BYBIT_SECRET = "your_bybit_secret_here"        # 실제 시크릿으로 교체
    
    # API 키가 없어도 공개 엔드포인트 테스트는 가능
    tester = ComprehensiveAPITester(
        binance_api_key=BINANCE_API_KEY if BINANCE_API_KEY != "your_binance_api_key_here" else None,
        binance_secret=BINANCE_SECRET if BINANCE_SECRET != "your_binance_secret_here" else None,
        bybit_api_key=BYBIT_API_KEY if BYBIT_API_KEY != "your_bybit_api_key_here" else None,
        bybit_secret=BYBIT_SECRET if BYBIT_SECRET != "your_bybit_secret_here" else None
    )
    
    # 전체 테스트 실행
    results = tester.run_full_test_suite()
    
    # 결과를 JSON 파일로 저장
    with open('api_test_results.json', 'w', encoding='utf-8') as f:
        json.dump(results, f, indent=2, ensure_ascii=False)
    
    print(f"\n💾 테스트 결과가 'api_test_results.json' 파일로 저장되었습니다.")
    
    return results

if __name__ == "__main__":
    main()
```

### 🎯 간단한 연결 테스트 스크립트

```python
def quick_connection_test():
    """빠른 연결 테스트 (API 키 불필요)"""
    print("⚡ 빠른 API 연결 테스트")
    print("-" * 40)
    
    # 바이낸스 테스트
    try:
        response = requests.get("https://fapi.binance.com/fapi/v1/ping", timeout=5)
        binance_status = "🟢 연결됨" if response.status_code == 200 else "🔴 연결 실패"
    except:
        binance_status = "🔴 연결 실패"
    
    # 바이비트 테스트
    try:
        response = requests.get("https://api.bybit.com/v5/market/time", timeout=5)
        bybit_status = "🟢 연결됨" if response.status_code == 200 else "🔴 연결 실패"
    except:
        bybit_status = "🔴 연결 실패"
    
    print(f"🟡 바이낸스: {binance_status}")
    print(f"🟠 바이비트: {bybit_status}")
    
    return binance_status, bybit_status

# 빠른 테스트 실행
if __name__ == "__main__":
    quick_connection_test()
```

이제 완전한 API 연결 테스트 스위트가 포함되었습니다! 이 테스트들을 통해 실제 거래소 API 연결 상태, 응답 시간, 데이터 품질 등을 종합적으로 확인할 수 있습니다.
