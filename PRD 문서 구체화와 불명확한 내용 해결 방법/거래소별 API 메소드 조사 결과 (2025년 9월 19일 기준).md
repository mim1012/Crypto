# ê±°ë˜ì†Œë³„ API ë©”ì†Œë“œ ì¡°ì‚¬ ê²°ê³¼ (2025ë…„ 9ì›” 19ì¼ ê¸°ì¤€)

## ğŸ“‹ ê°œìš”

PRDì— ëª…ì‹œëœ ì•”í˜¸í™”í ìë™ë§¤ë§¤ ì‹œìŠ¤í…œ ê¸°ëŠ¥ êµ¬í˜„ì„ ìœ„í•œ ë°”ì´ë‚¸ìŠ¤(Binance)ì™€ ë°”ì´ë¹„íŠ¸(Bybit) ê±°ë˜ì†Œì˜ ìµœì‹  API ë©”ì†Œë“œ í˜¸ì¶œ ë°©ì‹ì„ ì¡°ì‚¬í•œ ê²°ê³¼ì…ë‹ˆë‹¤.

---

## ğŸŸ¡ ë°”ì´ë‚¸ìŠ¤ ì„ ë¬¼ API (Binance Futures)

### ğŸ”— ê¸°ë³¸ ì •ë³´
- **Base URL**: `https://fapi.binance.com`
- **Testnet URL**: `https://testnet.binancefuture.com`
- **API ë²„ì „**: v1
- **ì¸ì¦ ë°©ì‹**: HMAC SHA256 ì„œëª…

### ğŸ” ì¸ì¦ í—¤ë”
```http
X-MBX-APIKEY: {API_KEY}
```

### ğŸ“Š 1. ì£¼ë¬¸ ìƒì„± (New Order)

#### HTTP ìš”ì²­
```http
POST /fapi/v1/order
```

#### í•„ìˆ˜ íŒŒë¼ë¯¸í„°
```json
{
  "symbol": "BTCUSDT",           // ê±°ë˜ ì‹¬ë³¼ (í•„ìˆ˜)
  "side": "BUY",                 // BUY ë˜ëŠ” SELL (í•„ìˆ˜)
  "type": "LIMIT",               // ì£¼ë¬¸ íƒ€ì… (í•„ìˆ˜)
  "timeInForce": "GTC",          // ì‹œê°„ ì¡°ê±´
  "quantity": "0.001",           // ìˆ˜ëŸ‰
  "price": "50000.00",           // ê°€ê²©
  "timestamp": 1632150000000,    // íƒ€ì„ìŠ¤íƒ¬í”„ (í•„ìˆ˜)
  "signature": "..."             // ì„œëª… (í•„ìˆ˜)
}
```

#### ì£¼ë¬¸ íƒ€ì…ë³„ ì¶”ê°€ íŒŒë¼ë¯¸í„°
| ì£¼ë¬¸ íƒ€ì… | ì¶”ê°€ í•„ìˆ˜ íŒŒë¼ë¯¸í„° |
|-----------|-------------------|
| `LIMIT` | `timeInForce`, `quantity`, `price` |
| `MARKET` | `quantity` |
| `STOP/TAKE_PROFIT` | `quantity`, `price`, `stopPrice` |
| `STOP_MARKET/TAKE_PROFIT_MARKET` | `stopPrice` |
| `TRAILING_STOP_MARKET` | `callbackRate` |

#### ì‘ë‹µ ì˜ˆì‹œ
```json
{
  "orderId": 22542179,
  "symbol": "BTCUSDT",
  "status": "NEW",
  "clientOrderId": "testOrder",
  "price": "50000.00",
  "avgPrice": "0.00000",
  "origQty": "0.001",
  "executedQty": "0",
  "cumQty": "0",
  "cumQuote": "0",
  "timeInForce": "GTC",
  "type": "LIMIT",
  "reduceOnly": false,
  "closePosition": false,
  "side": "BUY",
  "positionSide": "BOTH",
  "stopPrice": "0",
  "workingType": "CONTRACT_PRICE",
  "priceProtect": false,
  "origType": "LIMIT",
  "updateTime": 1566818724722
}
```

### ğŸ“ˆ 2. ì‹œì¥ ë°ì´í„° ì¡°íšŒ

#### í˜„ì¬ê°€ ì¡°íšŒ
```http
GET /fapi/v1/ticker/price?symbol=BTCUSDT
```

#### ì‘ë‹µ ì˜ˆì‹œ
```json
{
  "symbol": "BTCUSDT",
  "price": "50136.80000000"
}
```

#### ìº”ë“¤ ë°ì´í„° ì¡°íšŒ
```http
GET /fapi/v1/klines?symbol=BTCUSDT&interval=1m&limit=100
```

#### ì‘ë‹µ ì˜ˆì‹œ
```json
[
  [
    1499040000000,      // ì‹œì‘ ì‹œê°„
    "0.01634790",       // ì‹œê°€
    "0.80000000",       // ê³ ê°€
    "0.01575800",       // ì €ê°€
    "0.01577100",       // ì¢…ê°€
    "148976.11427815",  // ê±°ë˜ëŸ‰
    1499644799999,      // ì¢…ë£Œ ì‹œê°„
    "2434.19055334",    // Quote asset volume
    308,                // ê±°ë˜ íšŸìˆ˜
    "1756.87402397",    // Taker buy base asset volume
    "28.46694368",      // Taker buy quote asset volume
    "17928899.62484339" // ë¬´ì‹œ
  ]
]
```

### ğŸ“Š 3. í˜¸ê°€ ë°ì´í„° ì¡°íšŒ
```http
GET /fapi/v1/depth?symbol=BTCUSDT&limit=20
```

#### ì‘ë‹µ ì˜ˆì‹œ
```json
{
  "lastUpdateId": 1027024,
  "E": 1589436922972,
  "T": 1589436922959,
  "bids": [
    ["4.00000000", "431.00000000"]
  ],
  "asks": [
    ["4.00000200", "12.00000000"]
  ]
}
```

### ğŸ’¼ 4. í¬ì§€ì…˜ ì •ë³´ ì¡°íšŒ
```http
GET /fapi/v2/positionRisk
```

#### ì‘ë‹µ ì˜ˆì‹œ
```json
[
  {
    "symbol": "BTCUSDT",
    "positionAmt": "0.001",
    "entryPrice": "50000.0",
    "markPrice": "50136.80000000",
    "unRealizedProfit": "0.13680000",
    "liquidationPrice": "0",
    "leverage": "10",
    "maxNotionalValue": "25000",
    "marginType": "isolated",
    "isolatedMargin": "0.00000000",
    "isAutoAddMargin": "false",
    "positionSide": "BOTH",
    "notional": "50.13680000",
    "isolatedWallet": "0",
    "updateTime": 1625474304765
  }
]
```

---

## ğŸŸ  ë°”ì´ë¹„íŠ¸ API (Bybit V5)

### ğŸ”— ê¸°ë³¸ ì •ë³´
- **Base URL**: `https://api.bybit.com`
- **Testnet URL**: `https://api-testnet.bybit.com`
- **API ë²„ì „**: v5
- **ì¸ì¦ ë°©ì‹**: HMAC SHA256 ì„œëª…

### ğŸ” ì¸ì¦ í—¤ë”
```http
X-BAPI-API-KEY: {API_KEY}
X-BAPI-TIMESTAMP: {timestamp}
X-BAPI-SIGN: {signature}
X-BAPI-RECV-WINDOW: 5000
```

### ğŸ“Š 1. ì£¼ë¬¸ ìƒì„± (Place Order)

#### HTTP ìš”ì²­
```http
POST /v5/order/create
```

#### í•„ìˆ˜ íŒŒë¼ë¯¸í„°
```json
{
  "category": "linear",          // ìƒí’ˆ íƒ€ì… (í•„ìˆ˜)
  "symbol": "BTCUSDT",          // ê±°ë˜ ì‹¬ë³¼ (í•„ìˆ˜)
  "side": "Buy",                // Buy ë˜ëŠ” Sell (í•„ìˆ˜)
  "orderType": "Limit",         // ì£¼ë¬¸ íƒ€ì… (í•„ìˆ˜)
  "qty": "0.001",               // ìˆ˜ëŸ‰ (í•„ìˆ˜)
  "price": "50000.00"           // ê°€ê²©
}
```

#### ì¹´í…Œê³ ë¦¬ë³„ ì§€ì› ìƒí’ˆ
| ì¹´í…Œê³ ë¦¬ | ì„¤ëª… |
|----------|------|
| `linear` | USDT ë¬´ê¸°í•œ ì„ ë¬¼ |
| `inverse` | ì—­ë°©í–¥ ì„ ë¬¼ |
| `spot` | í˜„ë¬¼ ê±°ë˜ |
| `option` | ì˜µì…˜ ê±°ë˜ |

#### ì‘ë‹µ ì˜ˆì‹œ
```json
{
  "retCode": 0,
  "retMsg": "OK",
  "result": {
    "orderId": "1321003749386327552",
    "orderLinkId": "spot-test-postonly"
  },
  "retExtInfo": {},
  "time": 1672211918471
}
```

### ğŸ“ˆ 2. ì‹œì¥ ë°ì´í„° ì¡°íšŒ

#### í˜„ì¬ê°€ ì¡°íšŒ
```http
GET /v5/market/tickers?category=linear&symbol=BTCUSDT
```

#### ì‘ë‹µ ì˜ˆì‹œ
```json
{
  "retCode": 0,
  "retMsg": "OK",
  "result": {
    "category": "linear",
    "list": [
      {
        "symbol": "BTCUSDT",
        "lastPrice": "50136.80",
        "indexPrice": "50142.33",
        "markPrice": "50139.54",
        "prevPrice24h": "49500.00",
        "price24hPcnt": "0.0129",
        "highPrice24h": "50800.00",
        "lowPrice24h": "49200.00",
        "prevPrice1h": "50000.00",
        "openInterest": "15678.123",
        "openInterestValue": "785291234.12",
        "turnover24h": "2387584.123456",
        "volume24h": "47.123",
        "fundingRate": "0.0001",
        "nextFundingTime": "1672214400000",
        "predictedDeliveryPrice": "",
        "basisRate": "",
        "deliveryFeeRate": "",
        "deliveryTime": "0",
        "ask1Size": "1.123",
        "bid1Price": "50135.00",
        "ask1Price": "50140.00",
        "bid1Size": "0.456"
      }
    ]
  },
  "retExtInfo": {},
  "time": 1672211918471
}
```

#### ìº”ë“¤ ë°ì´í„° ì¡°íšŒ
```http
GET /v5/market/kline?category=linear&symbol=BTCUSDT&interval=1&limit=100
```

#### ì‘ë‹µ ì˜ˆì‹œ
```json
{
  "retCode": 0,
  "retMsg": "OK",
  "result": {
    "symbol": "BTCUSDT",
    "category": "linear",
    "list": [
      [
        "1672214400000",  // ì‹œì‘ ì‹œê°„
        "50000.00",       // ì‹œê°€
        "50200.00",       // ê³ ê°€
        "49800.00",       // ì €ê°€
        "50136.80",       // ì¢…ê°€
        "47.123",         // ê±°ë˜ëŸ‰
        "2387584.123456"  // ê±°ë˜ ê¸ˆì•¡
      ]
    ]
  },
  "retExtInfo": {},
  "time": 1672211918471
}
```

### ğŸ“Š 3. í˜¸ê°€ ë°ì´í„° ì¡°íšŒ
```http
GET /v5/market/orderbook?category=linear&symbol=BTCUSDT&limit=25
```

#### ì‘ë‹µ ì˜ˆì‹œ
```json
{
  "retCode": 0,
  "retMsg": "OK",
  "result": {
    "s": "BTCUSDT",
    "a": [
      ["50140.00", "0.123"],
      ["50141.00", "0.456"]
    ],
    "b": [
      ["50135.00", "0.789"],
      ["50134.00", "1.234"]
    ],
    "ts": 1672211918471,
    "u": 18521
  },
  "retExtInfo": {},
  "time": 1672211918471
}
```

### ğŸ’¼ 4. í¬ì§€ì…˜ ì •ë³´ ì¡°íšŒ
```http
GET /v5/position/list?category=linear&symbol=BTCUSDT
```

#### ì‘ë‹µ ì˜ˆì‹œ
```json
{
  "retCode": 0,
  "retMsg": "OK",
  "result": {
    "list": [
      {
        "positionIdx": 0,
        "riskId": 1,
        "riskLimitValue": "200000",
        "symbol": "BTCUSDT",
        "side": "Buy",
        "size": "0.001",
        "avgPrice": "50000.00",
        "positionValue": "50.00",
        "tradeMode": 0,
        "positionStatus": "Normal",
        "autoAddMargin": 0,
        "adlRankIndicator": 2,
        "leverage": "10",
        "positionBalance": "5.00",
        "markPrice": "50136.80",
        "liqPrice": "45000.00",
        "bustPrice": "44500.00",
        "positionMM": "0.25",
        "positionIM": "5.00",
        "tpslMode": "Full",
        "takeProfit": "55000.00",
        "stopLoss": "45000.00",
        "trailingStop": "0",
        "unrealisedPnl": "0.1368",
        "cumRealisedPnl": "0",
        "seq": 5723621632,
        "isReduceOnly": false,
        "mmrSysUpdatedTime": "",
        "leverageSysUpdatedTime": "",
        "createdTime": "1672211918471",
        "updatedTime": "1672211918471"
      }
    ],
    "nextPageCursor": "",
    "category": "linear"
  },
  "retExtInfo": {},
  "time": 1672211918471
}
```

---

## ğŸ”§ PRD ê¸°ëŠ¥ë³„ API ë§¤í•‘

### ğŸ“Š 1. ì´ë™í‰ê· ì„  ì¡°ê±´ êµ¬í˜„

#### í•„ìš”í•œ API í˜¸ì¶œ
```python
# ë°”ì´ë‚¸ìŠ¤
def get_moving_average_data(symbol, interval="1m", limit=4):
    url = f"https://fapi.binance.com/fapi/v1/klines"
    params = {
        "symbol": symbol,
        "interval": interval,
        "limit": limit
    }
    response = requests.get(url, params=params)
    return response.json()

# ë°”ì´ë¹„íŠ¸
def get_moving_average_data_bybit(symbol, interval="1", limit=4):
    url = f"https://api.bybit.com/v5/market/kline"
    params = {
        "category": "linear",
        "symbol": symbol,
        "interval": interval,
        "limit": limit
    }
    response = requests.get(url, params=params)
    return response.json()
```

### ğŸ“ˆ 2. Price Channel ì¡°ê±´ êµ¬í˜„

#### í•„ìš”í•œ API í˜¸ì¶œ
```python
# ë°”ì´ë‚¸ìŠ¤ - 20ì¼ ê³ ê°€/ì €ê°€ ë°ì´í„°
def get_price_channel_data(symbol, interval="1d", limit=20):
    url = f"https://fapi.binance.com/fapi/v1/klines"
    params = {
        "symbol": symbol,
        "interval": interval,
        "limit": limit
    }
    response = requests.get(url, params=params)
    klines = response.json()
    
    highs = [float(kline[2]) for kline in klines]  # ê³ ê°€
    lows = [float(kline[3]) for kline in klines]   # ì €ê°€
    
    upper_channel = max(highs)
    lower_channel = min(lows)
    middle_channel = (upper_channel + lower_channel) / 2
    
    return {
        "upper": upper_channel,
        "lower": lower_channel,
        "middle": middle_channel
    }
```

### ğŸ”” 3. í˜¸ê°€ ê°ì‹œ ì¡°ê±´ êµ¬í˜„

#### ì‹¤ì‹œê°„ í˜¸ê°€ ë°ì´í„°
```python
# ë°”ì´ë‚¸ìŠ¤ WebSocket
def binance_orderbook_stream(symbol):
    socket = f"wss://fstream.binance.com/ws/{symbol.lower()}@depth@100ms"
    # WebSocket ì—°ê²° ë° ì‹¤ì‹œê°„ í˜¸ê°€ ë°ì´í„° ìˆ˜ì‹ 

# ë°”ì´ë¹„íŠ¸ WebSocket
def bybit_orderbook_stream(symbol):
    socket = f"wss://stream.bybit.com/v5/public/linear"
    # WebSocket ì—°ê²° ë° ì‹¤ì‹œê°„ í˜¸ê°€ ë°ì´í„° ìˆ˜ì‹ 
```

### ğŸ•¯ï¸ 4. ìº”ë“¤ ìƒíƒœ ì¡°ê±´ êµ¬í˜„

#### ì‹¤ì‹œê°„ ìº”ë“¤ ë°ì´í„°
```python
# ë°”ì´ë‚¸ìŠ¤ - í˜„ì¬ ì§„í–‰ì¤‘ì¸ ìº”ë“¤
def get_current_candle(symbol):
    url = f"https://fapi.binance.com/fapi/v1/klines"
    params = {
        "symbol": symbol,
        "interval": "1m",
        "limit": 1
    }
    response = requests.get(url, params=params)
    candle = response.json()[0]
    
    open_price = float(candle[1])
    current_price = float(candle[4])
    
    return {
        "is_bullish": current_price > open_price,
        "is_bearish": current_price < open_price,
        "open": open_price,
        "current": current_price
    }
```

### âš¡ 5. ì£¼ë¬¸ ì‹¤í–‰ êµ¬í˜„

#### ë°”ì´ë‚¸ìŠ¤ ì£¼ë¬¸ ìƒì„±
```python
def create_binance_order(symbol, side, quantity, price=None, order_type="MARKET"):
    url = "https://fapi.binance.com/fapi/v1/order"
    
    params = {
        "symbol": symbol,
        "side": side,
        "type": order_type,
        "quantity": quantity,
        "timestamp": int(time.time() * 1000)
    }
    
    if order_type == "LIMIT":
        params["price"] = price
        params["timeInForce"] = "GTC"
    
    # ì„œëª… ìƒì„±
    query_string = "&".join([f"{k}={v}" for k, v in params.items()])
    signature = hmac.new(
        SECRET_KEY.encode('utf-8'),
        query_string.encode('utf-8'),
        hashlib.sha256
    ).hexdigest()
    params["signature"] = signature
    
    headers = {"X-MBX-APIKEY": API_KEY}
    response = requests.post(url, params=params, headers=headers)
    return response.json()
```

#### ë°”ì´ë¹„íŠ¸ ì£¼ë¬¸ ìƒì„±
```python
def create_bybit_order(symbol, side, quantity, price=None, order_type="Market"):
    url = "https://api.bybit.com/v5/order/create"
    timestamp = str(int(time.time() * 1000))
    
    data = {
        "category": "linear",
        "symbol": symbol,
        "side": side,
        "orderType": order_type,
        "qty": quantity
    }
    
    if order_type == "Limit":
        data["price"] = price
    
    # ì„œëª… ìƒì„±
    param_str = json.dumps(data, separators=(',', ':'))
    hash_payload = timestamp + API_KEY + "5000" + param_str
    signature = hmac.new(
        SECRET_KEY.encode('utf-8'),
        hash_payload.encode('utf-8'),
        hashlib.sha256
    ).hexdigest()
    
    headers = {
        "X-BAPI-API-KEY": API_KEY,
        "X-BAPI-TIMESTAMP": timestamp,
        "X-BAPI-SIGN": signature,
        "X-BAPI-RECV-WINDOW": "5000",
        "Content-Type": "application/json"
    }
    
    response = requests.post(url, json=data, headers=headers)
    return response.json()
```

---

## ğŸš¨ ì£¼ìš” ì°¨ì´ì  ë° ì£¼ì˜ì‚¬í•­

### ğŸ”„ API êµ¬ì¡° ì°¨ì´ì 

| í•­ëª© | ë°”ì´ë‚¸ìŠ¤ | ë°”ì´ë¹„íŠ¸ |
|------|----------|----------|
| **Base URL** | fapi.binance.com | api.bybit.com |
| **API ë²„ì „** | v1 | v5 |
| **ì¸ì¦ í—¤ë”** | X-MBX-APIKEY | X-BAPI-API-KEY |
| **ì„œëª… ë°©ì‹** | Query String | JSON Body |
| **ì£¼ë¬¸ ì‚¬ì´ë“œ** | BUY/SELL | Buy/Sell |
| **ì¹´í…Œê³ ë¦¬** | ì—†ìŒ | linear/inverse/spot |

### âš ï¸ ì œí•œì‚¬í•­

#### ë°”ì´ë‚¸ìŠ¤ ì œí•œ
- **ì£¼ë¬¸ ì œí•œ**: 10ì´ˆë‹¹ 1ê°œ, 1ë¶„ë‹¹ 1ê°œ
- **IP ì œí•œ**: ë¶„ë‹¹ 2400 ê°€ì¤‘ì¹˜
- **í¬ì§€ì…˜ ì œí•œ**: ì‹¬ë³¼ë‹¹ ìµœëŒ€ 200ê°œ í™œì„± ì£¼ë¬¸

#### ë°”ì´ë¹„íŠ¸ ì œí•œ
- **ì£¼ë¬¸ ì œí•œ**: ì‹¬ë³¼ë‹¹ ìµœëŒ€ 500ê°œ í™œì„± ì£¼ë¬¸
- **ì¡°ê±´ë¶€ ì£¼ë¬¸**: ì‹¬ë³¼ë‹¹ ìµœëŒ€ 10ê°œ
- **API ìš”ì²­**: ë¶„ë‹¹ 120íšŒ (ì¼ë°˜ ì‚¬ìš©ì)

### ğŸ” ë³´ì•ˆ ê³ ë ¤ì‚¬í•­

1. **API í‚¤ ê´€ë¦¬**: í™˜ê²½ ë³€ìˆ˜ ë˜ëŠ” ì•”í˜¸í™”ëœ ì„¤ì • íŒŒì¼ ì‚¬ìš©
2. **IP í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸**: ê°€ëŠ¥í•œ ê²½ìš° IP ì œí•œ ì„¤ì •
3. **ê¶Œí•œ ìµœì†Œí™”**: í•„ìš”í•œ ê¶Œí•œë§Œ ë¶€ì—¬ (READ, TRADE)
4. **ì„œëª… ê²€ì¦**: ëª¨ë“  ìš”ì²­ì— ì˜¬ë°”ë¥¸ ì„œëª… í¬í•¨

---

## ğŸ“ êµ¬í˜„ ê¶Œì¥ì‚¬í•­

### ğŸ—ï¸ ì•„í‚¤í…ì²˜ ì„¤ê³„
1. **ì¶”ìƒí™” ê³„ì¸µ**: ê±°ë˜ì†Œë³„ ì°¨ì´ì ì„ ì¶”ìƒí™”í•˜ëŠ” ì¸í„°í˜ì´ìŠ¤ êµ¬í˜„
2. **ì—ëŸ¬ ì²˜ë¦¬**: ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜, API ì œí•œ, ì˜ëª»ëœ íŒŒë¼ë¯¸í„° ë“± ì²˜ë¦¬
3. **ì¬ì‹œë„ ë¡œì§**: ì¼ì‹œì  ì˜¤ë¥˜ì— ëŒ€í•œ ì§€ìˆ˜ ë°±ì˜¤í”„ ì¬ì‹œë„
4. **ë¡œê¹… ì‹œìŠ¤í…œ**: ëª¨ë“  API í˜¸ì¶œê³¼ ì‘ë‹µ ë¡œê¹…

### ğŸ”„ ì‹¤ì‹œê°„ ë°ì´í„° ì²˜ë¦¬
1. **WebSocket ì—°ê²°**: ì‹¤ì‹œê°„ ê°€ê²©, í˜¸ê°€, ê±°ë˜ ë°ì´í„°
2. **ì—°ê²° ê´€ë¦¬**: ìë™ ì¬ì—°ê²°, í•˜íŠ¸ë¹„íŠ¸ ì²˜ë¦¬
3. **ë°ì´í„° ë²„í¼ë§**: ì¼ì‹œì  ì—°ê²° ëŠê¹€ ëŒ€ë¹„ ë°ì´í„° ë²„í¼
4. **ìŠ¤ë ˆë“œ ì•ˆì „ì„±**: ë©€í‹°ìŠ¤ë ˆë“œ í™˜ê²½ì—ì„œì˜ ë°ì´í„° ë™ê¸°í™”

ì´ ì¡°ì‚¬ ê²°ê³¼ë¥¼ ë°”íƒ•ìœ¼ë¡œ PRDì— ëª…ì‹œëœ ëª¨ë“  ê¸°ëŠ¥ì„ ì•ˆì •ì ì´ê³  íš¨ìœ¨ì ìœ¼ë¡œ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.


---

## ğŸŒ WebSocket API ì‹¤ì‹œê°„ ë°ì´í„° ìŠ¤íŠ¸ë¦¼

### ğŸŸ¡ ë°”ì´ë‚¸ìŠ¤ WebSocket ìŠ¤íŠ¸ë¦¼

#### ğŸ”— ê¸°ë³¸ ì—°ê²° ì •ë³´
- **Base URL**: `wss://fstream.binance.com`
- **API WebSocket**: `wss://ws-fapi.binance.com/ws-fapi/v1`
- **Ping ì£¼ê¸°**: 20ì´ˆë§ˆë‹¤ ping í”„ë ˆì„ ì „ì†¡

#### ğŸ“Š ì£¼ìš” ìŠ¤íŠ¸ë¦¼ ì—”ë“œí¬ì¸íŠ¸

##### 1. ì‹¤ì‹œê°„ ê°€ê²© ìŠ¤íŠ¸ë¦¼
```javascript
// ê°œë³„ ì‹¬ë³¼ ê°€ê²©
wss://fstream.binance.com/ws/btcusdt@ticker

// ëª¨ë“  ì‹¬ë³¼ ê°€ê²©
wss://fstream.binance.com/ws/!ticker@arr
```

##### 2. ìº”ë“¤ìŠ¤í‹± ë°ì´í„° ìŠ¤íŠ¸ë¦¼
```javascript
// 1ë¶„ë´‰ ìº”ë“¤
wss://fstream.binance.com/ws/btcusdt@kline_1m

// 5ë¶„ë´‰ ìº”ë“¤
wss://fstream.binance.com/ws/btcusdt@kline_5m
```

##### 3. í˜¸ê°€ ë°ì´í„° ìŠ¤íŠ¸ë¦¼
```javascript
// ì‹¤ì‹œê°„ í˜¸ê°€ (100ms ì—…ë°ì´íŠ¸)
wss://fstream.binance.com/ws/btcusdt@depth@100ms

// ë¶€ë¶„ í˜¸ê°€ (5ë‹¨ê³„)
wss://fstream.binance.com/ws/btcusdt@depth5@100ms
```

##### 4. ê±°ë˜ ë°ì´í„° ìŠ¤íŠ¸ë¦¼
```javascript
// ì‹¤ì‹œê°„ ê±°ë˜
wss://fstream.binance.com/ws/btcusdt@trade

// ì§‘ê³„ ê±°ë˜
wss://fstream.binance.com/ws/btcusdt@aggTrade
```

#### ğŸ“ WebSocket ë©”ì‹œì§€ ì˜ˆì‹œ

##### ê°€ê²© í‹°ì»¤ ì‘ë‹µ
```json
{
  "e": "24hrTicker",
  "E": 1672515782136,
  "s": "BTCUSDT",
  "p": "-0.0018",
  "P": "-0.0036",
  "w": "50123.45",
  "x": "50000.00",
  "c": "50136.80",
  "Q": "0.001",
  "b": "50135.00",
  "B": "0.123",
  "a": "50140.00",
  "A": "0.456",
  "o": "50154.80",
  "h": "50800.00",
  "l": "49200.00",
  "v": "47.123",
  "q": "2387584.123456",
  "O": 1672429382136,
  "C": 1672515782136,
  "F": 175142,
  "L": 175143,
  "n": 2
}
```

##### ìº”ë“¤ìŠ¤í‹± ì‘ë‹µ
```json
{
  "e": "kline",
  "E": 1672515782136,
  "s": "BTCUSDT",
  "k": {
    "t": 1672515780000,
    "T": 1672515839999,
    "s": "BTCUSDT",
    "i": "1m",
    "f": 175142,
    "L": 175143,
    "o": "50000.00",
    "c": "50136.80",
    "h": "50200.00",
    "l": "49800.00",
    "v": "0.123",
    "n": 2,
    "x": false,
    "q": "6168.456",
    "V": "0.056",
    "Q": "2804.123",
    "B": "0"
  }
}
```

### ğŸŸ  ë°”ì´ë¹„íŠ¸ WebSocket ìŠ¤íŠ¸ë¦¼

#### ğŸ”— ê¸°ë³¸ ì—°ê²° ì •ë³´
- **Public Stream**: `wss://stream.bybit.com/v5/public/linear`
- **Private Stream**: `wss://stream.bybit.com/v5/private`
- **Heartbeat**: 30ì´ˆë§ˆë‹¤ ping ì „ì†¡

#### ğŸ“Š ì£¼ìš” ìŠ¤íŠ¸ë¦¼ êµ¬ë…

##### 1. ì‹¤ì‹œê°„ ê°€ê²© êµ¬ë…
```json
{
  "op": "subscribe",
  "args": [
    "tickers.BTCUSDT"
  ]
}
```

##### 2. ìº”ë“¤ìŠ¤í‹± ë°ì´í„° êµ¬ë…
```json
{
  "op": "subscribe",
  "args": [
    "kline.1.BTCUSDT"
  ]
}
```

##### 3. í˜¸ê°€ ë°ì´í„° êµ¬ë…
```json
{
  "op": "subscribe",
  "args": [
    "orderbook.1.BTCUSDT"
  ]
}
```

##### 4. ê±°ë˜ ë°ì´í„° êµ¬ë…
```json
{
  "op": "subscribe",
  "args": [
    "publicTrade.BTCUSDT"
  ]
}
```

#### ğŸ“ WebSocket ë©”ì‹œì§€ ì˜ˆì‹œ

##### ê°€ê²© í‹°ì»¤ ì‘ë‹µ
```json
{
  "topic": "tickers.BTCUSDT",
  "type": "snapshot",
  "data": {
    "symbol": "BTCUSDT",
    "tickDirection": "PlusTick",
    "price24hPcnt": "0.0129",
    "lastPrice": "50136.80",
    "prevPrice24h": "49500.00",
    "highPrice24h": "50800.00",
    "lowPrice24h": "49200.00",
    "prevPrice1h": "50000.00",
    "markPrice": "50139.54",
    "indexPrice": "50142.33",
    "openInterest": "15678.123",
    "openInterestValue": "785291234.12",
    "turnover24h": "2387584.123456",
    "volume24h": "47.123",
    "nextFundingTime": "1672214400000",
    "fundingRate": "0.0001",
    "bid1Price": "50135.00",
    "bid1Size": "0.456",
    "ask1Price": "50140.00",
    "ask1Size": "1.123"
  },
  "cs": 2588407624,
  "ts": 1672515782136
}
```

##### ìº”ë“¤ìŠ¤í‹± ì‘ë‹µ
```json
{
  "topic": "kline.1.BTCUSDT",
  "data": [
    {
      "start": 1672515780000,
      "end": 1672515839999,
      "interval": "1",
      "open": "50000.00",
      "close": "50136.80",
      "high": "50200.00",
      "low": "49800.00",
      "volume": "0.123",
      "turnover": "6168.456",
      "confirm": false,
      "timestamp": 1672515782136
    }
  ],
  "ts": 1672515782136
}
```

---

## ğŸ”„ ì‹¤ì‹œê°„ ë°ì´í„° ì²˜ë¦¬ êµ¬í˜„ ì˜ˆì‹œ

### ğŸŸ¡ ë°”ì´ë‚¸ìŠ¤ WebSocket í´ë¼ì´ì–¸íŠ¸

```python
import websocket
import json
import threading

class BinanceWebSocketClient:
    def __init__(self, symbol="BTCUSDT"):
        self.symbol = symbol.lower()
        self.ws = None
        self.callbacks = {}
        
    def on_message(self, ws, message):
        try:
            data = json.loads(message)
            stream = data.get('stream', '')
            
            if 'ticker' in stream:
                self._handle_ticker(data['data'])
            elif 'kline' in stream:
                self._handle_kline(data['data'])
            elif 'depth' in stream:
                self._handle_depth(data['data'])
            elif 'trade' in stream:
                self._handle_trade(data['data'])
                
        except Exception as e:
            print(f"Error processing message: {e}")
    
    def on_error(self, ws, error):
        print(f"WebSocket error: {error}")
    
    def on_close(self, ws, close_status_code, close_msg):
        print("WebSocket connection closed")
    
    def on_open(self, ws):
        print("WebSocket connection opened")
        
        # êµ¬ë…í•  ìŠ¤íŠ¸ë¦¼ë“¤
        streams = [
            f"{self.symbol}@ticker",
            f"{self.symbol}@kline_1m",
            f"{self.symbol}@depth@100ms",
            f"{self.symbol}@trade"
        ]
        
        # ë³µí•© ìŠ¤íŠ¸ë¦¼ êµ¬ë…
        subscribe_msg = {
            "method": "SUBSCRIBE",
            "params": streams,
            "id": 1
        }
        ws.send(json.dumps(subscribe_msg))
    
    def _handle_ticker(self, data):
        if 'ticker' in self.callbacks:
            self.callbacks['ticker'](data)
    
    def _handle_kline(self, data):
        if 'kline' in self.callbacks:
            self.callbacks['kline'](data['k'])
    
    def _handle_depth(self, data):
        if 'depth' in self.callbacks:
            self.callbacks['depth'](data)
    
    def _handle_trade(self, data):
        if 'trade' in self.callbacks:
            self.callbacks['trade'](data)
    
    def set_callback(self, event_type, callback):
        self.callbacks[event_type] = callback
    
    def start(self):
        websocket.enableTrace(True)
        self.ws = websocket.WebSocketApp(
            "wss://fstream.binance.com/ws/",
            on_message=self.on_message,
            on_error=self.on_error,
            on_close=self.on_close,
            on_open=self.on_open
        )
        
        # ë³„ë„ ìŠ¤ë ˆë“œì—ì„œ ì‹¤í–‰
        wst = threading.Thread(target=self.ws.run_forever)
        wst.daemon = True
        wst.start()
        return wst

# ì‚¬ìš© ì˜ˆì‹œ
def on_price_update(data):
    print(f"Price: {data['c']}, Volume: {data['v']}")

def on_candle_update(data):
    print(f"Candle: O:{data['o']} H:{data['h']} L:{data['l']} C:{data['c']}")

client = BinanceWebSocketClient("BTCUSDT")
client.set_callback('ticker', on_price_update)
client.set_callback('kline', on_candle_update)
client.start()
```

### ğŸŸ  ë°”ì´ë¹„íŠ¸ WebSocket í´ë¼ì´ì–¸íŠ¸

```python
import websocket
import json
import threading
import time

class BybitWebSocketClient:
    def __init__(self, symbol="BTCUSDT"):
        self.symbol = symbol
        self.ws = None
        self.callbacks = {}
        self.ping_thread = None
        
    def on_message(self, ws, message):
        try:
            data = json.loads(message)
            
            if 'topic' in data:
                topic = data['topic']
                
                if 'tickers' in topic:
                    self._handle_ticker(data['data'])
                elif 'kline' in topic:
                    self._handle_kline(data['data'][0])
                elif 'orderbook' in topic:
                    self._handle_orderbook(data['data'])
                elif 'publicTrade' in topic:
                    self._handle_trade(data['data'][0])
            elif data.get('op') == 'pong':
                print("Received pong")
                
        except Exception as e:
            print(f"Error processing message: {e}")
    
    def on_error(self, ws, error):
        print(f"WebSocket error: {error}")
    
    def on_close(self, ws, close_status_code, close_msg):
        print("WebSocket connection closed")
        if self.ping_thread:
            self.ping_thread.join()
    
    def on_open(self, ws):
        print("WebSocket connection opened")
        
        # êµ¬ë… ë©”ì‹œì§€
        subscribe_msg = {
            "op": "subscribe",
            "args": [
                f"tickers.{self.symbol}",
                f"kline.1.{self.symbol}",
                f"orderbook.1.{self.symbol}",
                f"publicTrade.{self.symbol}"
            ]
        }
        ws.send(json.dumps(subscribe_msg))
        
        # Ping ìŠ¤ë ˆë“œ ì‹œì‘
        self.ping_thread = threading.Thread(target=self._ping_loop)
        self.ping_thread.daemon = True
        self.ping_thread.start()
    
    def _ping_loop(self):
        while self.ws and not self.ws.sock.closed:
            time.sleep(30)  # 30ì´ˆë§ˆë‹¤ ping
            if self.ws and not self.ws.sock.closed:
                ping_msg = {"op": "ping"}
                self.ws.send(json.dumps(ping_msg))
    
    def _handle_ticker(self, data):
        if 'ticker' in self.callbacks:
            self.callbacks['ticker'](data)
    
    def _handle_kline(self, data):
        if 'kline' in self.callbacks:
            self.callbacks['kline'](data)
    
    def _handle_orderbook(self, data):
        if 'orderbook' in self.callbacks:
            self.callbacks['orderbook'](data)
    
    def _handle_trade(self, data):
        if 'trade' in self.callbacks:
            self.callbacks['trade'](data)
    
    def set_callback(self, event_type, callback):
        self.callbacks[event_type] = callback
    
    def start(self):
        websocket.enableTrace(True)
        self.ws = websocket.WebSocketApp(
            "wss://stream.bybit.com/v5/public/linear",
            on_message=self.on_message,
            on_error=self.on_error,
            on_close=self.on_close,
            on_open=self.on_open
        )
        
        # ë³„ë„ ìŠ¤ë ˆë“œì—ì„œ ì‹¤í–‰
        wst = threading.Thread(target=self.ws.run_forever)
        wst.daemon = True
        wst.start()
        return wst

# ì‚¬ìš© ì˜ˆì‹œ
def on_bybit_price_update(data):
    print(f"Bybit Price: {data['lastPrice']}, Volume: {data['volume24h']}")

def on_bybit_candle_update(data):
    print(f"Bybit Candle: O:{data['open']} H:{data['high']} L:{data['low']} C:{data['close']}")

client = BybitWebSocketClient("BTCUSDT")
client.set_callback('ticker', on_bybit_price_update)
client.set_callback('kline', on_bybit_candle_update)
client.start()
```

---

## ğŸ”§ í†µí•© ì‹¤ì‹œê°„ ë°ì´í„° ê´€ë¦¬ì

```python
class RealTimeDataManager:
    def __init__(self):
        self.binance_client = None
        self.bybit_client = None
        self.data_cache = {
            'binance': {},
            'bybit': {}
        }
        self.callbacks = {}
    
    def start_binance_stream(self, symbol):
        self.binance_client = BinanceWebSocketClient(symbol)
        self.binance_client.set_callback('ticker', self._on_binance_ticker)
        self.binance_client.set_callback('kline', self._on_binance_kline)
        self.binance_client.set_callback('depth', self._on_binance_depth)
        self.binance_client.start()
    
    def start_bybit_stream(self, symbol):
        self.bybit_client = BybitWebSocketClient(symbol)
        self.bybit_client.set_callback('ticker', self._on_bybit_ticker)
        self.bybit_client.set_callback('kline', self._on_bybit_kline)
        self.bybit_client.set_callback('orderbook', self._on_bybit_orderbook)
        self.bybit_client.start()
    
    def _on_binance_ticker(self, data):
        self.data_cache['binance']['ticker'] = data
        self._trigger_callback('price_update', 'binance', data)
    
    def _on_binance_kline(self, data):
        self.data_cache['binance']['kline'] = data
        self._trigger_callback('candle_update', 'binance', data)
    
    def _on_binance_depth(self, data):
        self.data_cache['binance']['depth'] = data
        self._trigger_callback('orderbook_update', 'binance', data)
    
    def _on_bybit_ticker(self, data):
        self.data_cache['bybit']['ticker'] = data
        self._trigger_callback('price_update', 'bybit', data)
    
    def _on_bybit_kline(self, data):
        self.data_cache['bybit']['kline'] = data
        self._trigger_callback('candle_update', 'bybit', data)
    
    def _on_bybit_orderbook(self, data):
        self.data_cache['bybit']['orderbook'] = data
        self._trigger_callback('orderbook_update', 'bybit', data)
    
    def _trigger_callback(self, event_type, exchange, data):
        if event_type in self.callbacks:
            for callback in self.callbacks[event_type]:
                try:
                    callback(exchange, data)
                except Exception as e:
                    print(f"Callback error: {e}")
    
    def add_callback(self, event_type, callback):
        if event_type not in self.callbacks:
            self.callbacks[event_type] = []
        self.callbacks[event_type].append(callback)
    
    def get_current_price(self, exchange):
        if exchange == 'binance':
            ticker = self.data_cache['binance'].get('ticker')
            return float(ticker['c']) if ticker else None
        elif exchange == 'bybit':
            ticker = self.data_cache['bybit'].get('ticker')
            return float(ticker['lastPrice']) if ticker else None
    
    def get_current_candle(self, exchange):
        if exchange == 'binance':
            return self.data_cache['binance'].get('kline')
        elif exchange == 'bybit':
            return self.data_cache['bybit'].get('kline')

# ì‚¬ìš© ì˜ˆì‹œ
def on_price_change(exchange, data):
    if exchange == 'binance':
        price = data['c']
    else:  # bybit
        price = data['lastPrice']
    print(f"{exchange.upper()} í˜„ì¬ê°€: {price}")

def on_candle_change(exchange, data):
    if exchange == 'binance':
        candle_info = f"O:{data['o']} C:{data['c']}"
    else:  # bybit
        candle_info = f"O:{data['open']} C:{data['close']}"
    print(f"{exchange.upper()} ìº”ë“¤: {candle_info}")

# ì‹¤ì‹œê°„ ë°ì´í„° ê´€ë¦¬ì ì‹œì‘
manager = RealTimeDataManager()
manager.add_callback('price_update', on_price_change)
manager.add_callback('candle_update', on_candle_change)

manager.start_binance_stream("BTCUSDT")
manager.start_bybit_stream("BTCUSDT")
```

ì´ WebSocket êµ¬í˜„ì„ í†µí•´ PRDì— ëª…ì‹œëœ ì‹¤ì‹œê°„ ì¡°ê±´ ê°ì‹œ ê¸°ëŠ¥ì„ ì™„ë²½í•˜ê²Œ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

---

## ğŸ§ª API ì—°ê²° í…ŒìŠ¤íŠ¸ ìŠ¤ìœ„íŠ¸

### ğŸ”§ í…ŒìŠ¤íŠ¸ í™˜ê²½ ì„¤ì •

```python
import requests
import hmac
import hashlib
import time
import json
import websocket
import threading
from datetime import datetime
import ssl

class APITester:
    def __init__(self):
        self.test_results = {}
        self.start_time = None
        self.end_time = None
    
    def run_all_tests(self):
        """ëª¨ë“  API í…ŒìŠ¤íŠ¸ ì‹¤í–‰"""
        print("ğŸš€ API ì—°ê²° í…ŒìŠ¤íŠ¸ ì‹œì‘...")
        self.start_time = time.time()
        
        # ë°”ì´ë‚¸ìŠ¤ í…ŒìŠ¤íŠ¸
        print("\nğŸŸ¡ ë°”ì´ë‚¸ìŠ¤ API í…ŒìŠ¤íŠ¸")
        binance_results = self.test_binance_api()
        
        # ë°”ì´ë¹„íŠ¸ í…ŒìŠ¤íŠ¸  
        print("\nğŸŸ  ë°”ì´ë¹„íŠ¸ API í…ŒìŠ¤íŠ¸")
        bybit_results = self.test_bybit_api()
        
        self.end_time = time.time()
        
        # ê²°ê³¼ ì¶œë ¥
        self.print_test_results(binance_results, bybit_results)
        
        return {
            'binance': binance_results,
            'bybit': bybit_results,
            'total_time': self.end_time - self.start_time
        }
```

### ğŸŸ¡ ë°”ì´ë‚¸ìŠ¤ API ì—°ê²° í…ŒìŠ¤íŠ¸

```python
class BinanceAPITester:
    def __init__(self, api_key=None, secret_key=None):
        self.api_key = api_key
        self.secret_key = secret_key
        self.base_url = "https://fapi.binance.com"
        self.testnet_url = "https://testnet.binancefuture.com"
        
    def test_connection(self):
        """ê¸°ë³¸ ì—°ê²° í…ŒìŠ¤íŠ¸"""
        try:
            start_time = time.time()
            response = requests.get(f"{self.base_url}/fapi/v1/ping", timeout=10)
            end_time = time.time()
            
            return {
                'status': 'SUCCESS' if response.status_code == 200 else 'FAILED',
                'response_time': round((end_time - start_time) * 1000, 2),
                'status_code': response.status_code,
                'error': None
            }
        except Exception as e:
            return {
                'status': 'FAILED',
                'response_time': None,
                'status_code': None,
                'error': str(e)
            }
    
    def test_server_time(self):
        """ì„œë²„ ì‹œê°„ ë™ê¸°í™” í…ŒìŠ¤íŠ¸"""
        try:
            start_time = time.time()
            response = requests.get(f"{self.base_url}/fapi/v1/time", timeout=10)
            end_time = time.time()
            
            if response.status_code == 200:
                server_time = response.json()['serverTime']
                local_time = int(time.time() * 1000)
                time_diff = abs(server_time - local_time)
                
                return {
                    'status': 'SUCCESS',
                    'response_time': round((end_time - start_time) * 1000, 2),
                    'server_time': server_time,
                    'local_time': local_time,
                    'time_diff_ms': time_diff,
                    'sync_status': 'GOOD' if time_diff < 1000 else 'WARNING',
                    'error': None
                }
            else:
                return {
                    'status': 'FAILED',
                    'response_time': round((end_time - start_time) * 1000, 2),
                    'error': f"HTTP {response.status_code}"
                }
        except Exception as e:
            return {
                'status': 'FAILED',
                'response_time': None,
                'error': str(e)
            }
    
    def test_exchange_info(self):
        """ê±°ë˜ì†Œ ì •ë³´ ì¡°íšŒ í…ŒìŠ¤íŠ¸"""
        try:
            start_time = time.time()
            response = requests.get(f"{self.base_url}/fapi/v1/exchangeInfo", timeout=15)
            end_time = time.time()
            
            if response.status_code == 200:
                data = response.json()
                symbols_count = len(data.get('symbols', []))
                
                return {
                    'status': 'SUCCESS',
                    'response_time': round((end_time - start_time) * 1000, 2),
                    'symbols_count': symbols_count,
                    'server_time': data.get('serverTime'),
                    'error': None
                }
            else:
                return {
                    'status': 'FAILED',
                    'response_time': round((end_time - start_time) * 1000, 2),
                    'error': f"HTTP {response.status_code}"
                }
        except Exception as e:
            return {
                'status': 'FAILED',
                'response_time': None,
                'error': str(e)
            }
    
    def test_market_data(self, symbol="BTCUSDT"):
        """ì‹œì¥ ë°ì´í„° ì¡°íšŒ í…ŒìŠ¤íŠ¸"""
        tests = {}
        
        # í˜„ì¬ê°€ í…ŒìŠ¤íŠ¸
        try:
            start_time = time.time()
            response = requests.get(f"{self.base_url}/fapi/v1/ticker/price", 
                                  params={'symbol': symbol}, timeout=10)
            end_time = time.time()
            
            if response.status_code == 200:
                data = response.json()
                tests['price'] = {
                    'status': 'SUCCESS',
                    'response_time': round((end_time - start_time) * 1000, 2),
                    'price': data.get('price'),
                    'error': None
                }
            else:
                tests['price'] = {
                    'status': 'FAILED',
                    'response_time': round((end_time - start_time) * 1000, 2),
                    'error': f"HTTP {response.status_code}"
                }
        except Exception as e:
            tests['price'] = {
                'status': 'FAILED',
                'response_time': None,
                'error': str(e)
            }
        
        # ìº”ë“¤ ë°ì´í„° í…ŒìŠ¤íŠ¸
        try:
            start_time = time.time()
            response = requests.get(f"{self.base_url}/fapi/v1/klines", 
                                  params={'symbol': symbol, 'interval': '1m', 'limit': 5}, 
                                  timeout=10)
            end_time = time.time()
            
            if response.status_code == 200:
                data = response.json()
                tests['klines'] = {
                    'status': 'SUCCESS',
                    'response_time': round((end_time - start_time) * 1000, 2),
                    'candles_count': len(data),
                    'latest_close': data[-1][4] if data else None,
                    'error': None
                }
            else:
                tests['klines'] = {
                    'status': 'FAILED',
                    'response_time': round((end_time - start_time) * 1000, 2),
                    'error': f"HTTP {response.status_code}"
                }
        except Exception as e:
            tests['klines'] = {
                'status': 'FAILED',
                'response_time': None,
                'error': str(e)
            }
        
        # í˜¸ê°€ ë°ì´í„° í…ŒìŠ¤íŠ¸
        try:
            start_time = time.time()
            response = requests.get(f"{self.base_url}/fapi/v1/depth", 
                                  params={'symbol': symbol, 'limit': 10}, 
                                  timeout=10)
            end_time = time.time()
            
            if response.status_code == 200:
                data = response.json()
                tests['depth'] = {
                    'status': 'SUCCESS',
                    'response_time': round((end_time - start_time) * 1000, 2),
                    'bids_count': len(data.get('bids', [])),
                    'asks_count': len(data.get('asks', [])),
                    'best_bid': data['bids'][0][0] if data.get('bids') else None,
                    'best_ask': data['asks'][0][0] if data.get('asks') else None,
                    'error': None
                }
            else:
                tests['depth'] = {
                    'status': 'FAILED',
                    'response_time': round((end_time - start_time) * 1000, 2),
                    'error': f"HTTP {response.status_code}"
                }
        except Exception as e:
            tests['depth'] = {
                'status': 'FAILED',
                'response_time': None,
                'error': str(e)
            }
        
        return tests
    
    def test_authenticated_endpoints(self):
        """ì¸ì¦ì´ í•„ìš”í•œ ì—”ë“œí¬ì¸íŠ¸ í…ŒìŠ¤íŠ¸"""
        if not self.api_key or not self.secret_key:
            return {
                'account_info': {
                    'status': 'SKIPPED',
                    'error': 'API í‚¤ê°€ ì œê³µë˜ì§€ ì•ŠìŒ'
                },
                'position_info': {
                    'status': 'SKIPPED', 
                    'error': 'API í‚¤ê°€ ì œê³µë˜ì§€ ì•ŠìŒ'
                }
            }
        
        tests = {}
        
        # ê³„ì¢Œ ì •ë³´ í…ŒìŠ¤íŠ¸
        try:
            timestamp = int(time.time() * 1000)
            query_string = f"timestamp={timestamp}"
            signature = hmac.new(
                self.secret_key.encode('utf-8'),
                query_string.encode('utf-8'),
                hashlib.sha256
            ).hexdigest()
            
            headers = {'X-MBX-APIKEY': self.api_key}
            params = {'timestamp': timestamp, 'signature': signature}
            
            start_time = time.time()
            response = requests.get(f"{self.base_url}/fapi/v2/account", 
                                  params=params, headers=headers, timeout=10)
            end_time = time.time()
            
            if response.status_code == 200:
                data = response.json()
                tests['account_info'] = {
                    'status': 'SUCCESS',
                    'response_time': round((end_time - start_time) * 1000, 2),
                    'total_wallet_balance': data.get('totalWalletBalance'),
                    'total_unrealized_pnl': data.get('totalUnrealizedProfit'),
                    'assets_count': len(data.get('assets', [])),
                    'error': None
                }
            else:
                tests['account_info'] = {
                    'status': 'FAILED',
                    'response_time': round((end_time - start_time) * 1000, 2),
                    'error': f"HTTP {response.status_code}: {response.text}"
                }
        except Exception as e:
            tests['account_info'] = {
                'status': 'FAILED',
                'response_time': None,
                'error': str(e)
            }
        
        # í¬ì§€ì…˜ ì •ë³´ í…ŒìŠ¤íŠ¸
        try:
            timestamp = int(time.time() * 1000)
            query_string = f"timestamp={timestamp}"
            signature = hmac.new(
                self.secret_key.encode('utf-8'),
                query_string.encode('utf-8'),
                hashlib.sha256
            ).hexdigest()
            
            headers = {'X-MBX-APIKEY': self.api_key}
            params = {'timestamp': timestamp, 'signature': signature}
            
            start_time = time.time()
            response = requests.get(f"{self.base_url}/fapi/v2/positionRisk", 
                                  params=params, headers=headers, timeout=10)
            end_time = time.time()
            
            if response.status_code == 200:
                data = response.json()
                active_positions = [pos for pos in data if float(pos.get('positionAmt', 0)) != 0]
                
                tests['position_info'] = {
                    'status': 'SUCCESS',
                    'response_time': round((end_time - start_time) * 1000, 2),
                    'total_positions': len(data),
                    'active_positions': len(active_positions),
                    'error': None
                }
            else:
                tests['position_info'] = {
                    'status': 'FAILED',
                    'response_time': round((end_time - start_time) * 1000, 2),
                    'error': f"HTTP {response.status_code}: {response.text}"
                }
        except Exception as e:
            tests['position_info'] = {
                'status': 'FAILED',
                'response_time': None,
                'error': str(e)
            }
        
        return tests
    
    def test_websocket_connection(self, symbol="BTCUSDT"):
        """WebSocket ì—°ê²° í…ŒìŠ¤íŠ¸"""
        test_result = {
            'status': 'TESTING',
            'connection_time': None,
            'messages_received': 0,
            'error': None
        }
        
        def on_message(ws, message):
            test_result['messages_received'] += 1
            if test_result['messages_received'] >= 3:  # 3ê°œ ë©”ì‹œì§€ ë°›ìœ¼ë©´ ì¢…ë£Œ
                ws.close()
        
        def on_error(ws, error):
            test_result['status'] = 'FAILED'
            test_result['error'] = str(error)
        
        def on_close(ws, close_status_code, close_msg):
            if test_result['messages_received'] >= 3:
                test_result['status'] = 'SUCCESS'
        
        def on_open(ws):
            test_result['connection_time'] = time.time() - start_time
            # ê°€ê²© ìŠ¤íŠ¸ë¦¼ êµ¬ë…
            subscribe_msg = {
                "method": "SUBSCRIBE",
                "params": [f"{symbol.lower()}@ticker"],
                "id": 1
            }
            ws.send(json.dumps(subscribe_msg))
        
        try:
            start_time = time.time()
            ws = websocket.WebSocketApp(
                "wss://fstream.binance.com/ws/",
                on_message=on_message,
                on_error=on_error,
                on_close=on_close,
                on_open=on_open
            )
            
            # 5ì´ˆ íƒ€ì„ì•„ì›ƒìœ¼ë¡œ ì‹¤í–‰
            wst = threading.Thread(target=ws.run_forever, kwargs={'sslopt': {"cert_reqs": ssl.CERT_NONE}})
            wst.daemon = True
            wst.start()
            wst.join(timeout=5)
            
            if test_result['status'] == 'TESTING':
                test_result['status'] = 'TIMEOUT'
                test_result['error'] = '5ì´ˆ ë‚´ì— ì‘ë‹µ ì—†ìŒ'
            
        except Exception as e:
            test_result['status'] = 'FAILED'
            test_result['error'] = str(e)
        
        return test_result
```

### ğŸŸ  ë°”ì´ë¹„íŠ¸ API ì—°ê²° í…ŒìŠ¤íŠ¸

```python
class BybitAPITester:
    def __init__(self, api_key=None, secret_key=None):
        self.api_key = api_key
        self.secret_key = secret_key
        self.base_url = "https://api.bybit.com"
        self.testnet_url = "https://api-testnet.bybit.com"
    
    def _generate_signature(self, timestamp, params_str=""):
        """ë°”ì´ë¹„íŠ¸ ì„œëª… ìƒì„±"""
        param_str = str(timestamp) + self.api_key + "5000" + params_str
        return hmac.new(
            self.secret_key.encode('utf-8'),
            param_str.encode('utf-8'),
            hashlib.sha256
        ).hexdigest()
    
    def test_connection(self):
        """ê¸°ë³¸ ì—°ê²° í…ŒìŠ¤íŠ¸"""
        try:
            start_time = time.time()
            response = requests.get(f"{self.base_url}/v5/market/time", timeout=10)
            end_time = time.time()
            
            if response.status_code == 200:
                data = response.json()
                return {
                    'status': 'SUCCESS' if data['retCode'] == 0 else 'FAILED',
                    'response_time': round((end_time - start_time) * 1000, 2),
                    'server_time': data['time'],
                    'ret_msg': data['retMsg'],
                    'error': None
                }
            else:
                return {
                    'status': 'FAILED',
                    'response_time': round((end_time - start_time) * 1000, 2),
                    'error': f"HTTP {response.status_code}"
                }
        except Exception as e:
            return {
                'status': 'FAILED',
                'response_time': None,
                'error': str(e)
            }
    
    def test_server_time(self):
        """ì„œë²„ ì‹œê°„ ë™ê¸°í™” í…ŒìŠ¤íŠ¸"""
        try:
            start_time = time.time()
            response = requests.get(f"{self.base_url}/v5/market/time", timeout=10)
            end_time = time.time()
            
            if response.status_code == 200:
                data = response.json()
                if data['retCode'] == 0:
                    server_time = int(data['time'])
                    local_time = int(time.time() * 1000)
                    time_diff = abs(server_time - local_time)
                    
                    return {
                        'status': 'SUCCESS',
                        'response_time': round((end_time - start_time) * 1000, 2),
                        'server_time': server_time,
                        'local_time': local_time,
                        'time_diff_ms': time_diff,
                        'sync_status': 'GOOD' if time_diff < 1000 else 'WARNING',
                        'error': None
                    }
                else:
                    return {
                        'status': 'FAILED',
                        'response_time': round((end_time - start_time) * 1000, 2),
                        'error': data['retMsg']
                    }
            else:
                return {
                    'status': 'FAILED',
                    'response_time': round((end_time - start_time) * 1000, 2),
                    'error': f"HTTP {response.status_code}"
                }
        except Exception as e:
            return {
                'status': 'FAILED',
                'response_time': None,
                'error': str(e)
            }
    
    def test_instruments_info(self, category="linear"):
        """ê±°ë˜ ìƒí’ˆ ì •ë³´ ì¡°íšŒ í…ŒìŠ¤íŠ¸"""
        try:
            start_time = time.time()
            response = requests.get(f"{self.base_url}/v5/market/instruments-info", 
                                  params={'category': category}, timeout=15)
            end_time = time.time()
            
            if response.status_code == 200:
                data = response.json()
                if data['retCode'] == 0:
                    symbols_count = len(data['result']['list'])
                    
                    return {
                        'status': 'SUCCESS',
                        'response_time': round((end_time - start_time) * 1000, 2),
                        'category': category,
                        'symbols_count': symbols_count,
                        'error': None
                    }
                else:
                    return {
                        'status': 'FAILED',
                        'response_time': round((end_time - start_time) * 1000, 2),
                        'error': data['retMsg']
                    }
            else:
                return {
                    'status': 'FAILED',
                    'response_time': round((end_time - start_time) * 1000, 2),
                    'error': f"HTTP {response.status_code}"
                }
        except Exception as e:
            return {
                'status': 'FAILED',
                'response_time': None,
                'error': str(e)
            }
    
    def test_market_data(self, symbol="BTCUSDT", category="linear"):
        """ì‹œì¥ ë°ì´í„° ì¡°íšŒ í…ŒìŠ¤íŠ¸"""
        tests = {}
        
        # í˜„ì¬ê°€ í…ŒìŠ¤íŠ¸
        try:
            start_time = time.time()
            response = requests.get(f"{self.base_url}/v5/market/tickers", 
                                  params={'category': category, 'symbol': symbol}, 
                                  timeout=10)
            end_time = time.time()
            
            if response.status_code == 200:
                data = response.json()
                if data['retCode'] == 0 and data['result']['list']:
                    ticker = data['result']['list'][0]
                    tests['ticker'] = {
                        'status': 'SUCCESS',
                        'response_time': round((end_time - start_time) * 1000, 2),
                        'last_price': ticker.get('lastPrice'),
                        'mark_price': ticker.get('markPrice'),
                        'index_price': ticker.get('indexPrice'),
                        'volume_24h': ticker.get('volume24h'),
                        'error': None
                    }
                else:
                    tests['ticker'] = {
                        'status': 'FAILED',
                        'response_time': round((end_time - start_time) * 1000, 2),
                        'error': data['retMsg']
                    }
            else:
                tests['ticker'] = {
                    'status': 'FAILED',
                    'response_time': round((end_time - start_time) * 1000, 2),
                    'error': f"HTTP {response.status_code}"
                }
        except Exception as e:
            tests['ticker'] = {
                'status': 'FAILED',
                'response_time': None,
                'error': str(e)
            }
        
        # ìº”ë“¤ ë°ì´í„° í…ŒìŠ¤íŠ¸
        try:
            start_time = time.time()
            response = requests.get(f"{self.base_url}/v5/market/kline", 
                                  params={'category': category, 'symbol': symbol, 
                                         'interval': '1', 'limit': 5}, 
                                  timeout=10)
            end_time = time.time()
            
            if response.status_code == 200:
                data = response.json()
                if data['retCode'] == 0:
                    klines = data['result']['list']
                    tests['klines'] = {
                        'status': 'SUCCESS',
                        'response_time': round((end_time - start_time) * 1000, 2),
                        'candles_count': len(klines),
                        'latest_close': klines[0][4] if klines else None,
                        'error': None
                    }
                else:
                    tests['klines'] = {
                        'status': 'FAILED',
                        'response_time': round((end_time - start_time) * 1000, 2),
                        'error': data['retMsg']
                    }
            else:
                tests['klines'] = {
                    'status': 'FAILED',
                    'response_time': round((end_time - start_time) * 1000, 2),
                    'error': f"HTTP {response.status_code}"
                }
        except Exception as e:
            tests['klines'] = {
                'status': 'FAILED',
                'response_time': None,
                'error': str(e)
            }
        
        # í˜¸ê°€ ë°ì´í„° í…ŒìŠ¤íŠ¸
        try:
            start_time = time.time()
            response = requests.get(f"{self.base_url}/v5/market/orderbook", 
                                  params={'category': category, 'symbol': symbol, 'limit': 25}, 
                                  timeout=10)
            end_time = time.time()
            
            if response.status_code == 200:
                data = response.json()
                if data['retCode'] == 0:
                    orderbook = data['result']
                    tests['orderbook'] = {
                        'status': 'SUCCESS',
                        'response_time': round((end_time - start_time) * 1000, 2),
                        'bids_count': len(orderbook.get('b', [])),
                        'asks_count': len(orderbook.get('a', [])),
                        'best_bid': orderbook['b'][0][0] if orderbook.get('b') else None,
                        'best_ask': orderbook['a'][0][0] if orderbook.get('a') else None,
                        'error': None
                    }
                else:
                    tests['orderbook'] = {
                        'status': 'FAILED',
                        'response_time': round((end_time - start_time) * 1000, 2),
                        'error': data['retMsg']
                    }
            else:
                tests['orderbook'] = {
                    'status': 'FAILED',
                    'response_time': round((end_time - start_time) * 1000, 2),
                    'error': f"HTTP {response.status_code}"
                }
        except Exception as e:
            tests['orderbook'] = {
                'status': 'FAILED',
                'response_time': None,
                'error': str(e)
            }
        
        return tests
    
    def test_authenticated_endpoints(self):
        """ì¸ì¦ì´ í•„ìš”í•œ ì—”ë“œí¬ì¸íŠ¸ í…ŒìŠ¤íŠ¸"""
        if not self.api_key or not self.secret_key:
            return {
                'wallet_balance': {
                    'status': 'SKIPPED',
                    'error': 'API í‚¤ê°€ ì œê³µë˜ì§€ ì•ŠìŒ'
                },
                'position_info': {
                    'status': 'SKIPPED',
                    'error': 'API í‚¤ê°€ ì œê³µë˜ì§€ ì•ŠìŒ'
                }
            }
        
        tests = {}
        
        # ì§€ê°‘ ì”ê³  í…ŒìŠ¤íŠ¸
        try:
            timestamp = str(int(time.time() * 1000))
            params = {"accountType": "UNIFIED"}
            params_str = json.dumps(params, separators=(',', ':'))
            signature = self._generate_signature(timestamp, params_str)
            
            headers = {
                'X-BAPI-API-KEY': self.api_key,
                'X-BAPI-TIMESTAMP': timestamp,
                'X-BAPI-SIGN': signature,
                'X-BAPI-RECV-WINDOW': '5000',
                'Content-Type': 'application/json'
            }
            
            start_time = time.time()
            response = requests.get(f"{self.base_url}/v5/account/wallet-balance", 
                                  params=params, headers=headers, timeout=10)
            end_time = time.time()
            
            if response.status_code == 200:
                data = response.json()
                if data['retCode'] == 0:
                    wallet_list = data['result']['list']
                    tests['wallet_balance'] = {
                        'status': 'SUCCESS',
                        'response_time': round((end_time - start_time) * 1000, 2),
                        'accounts_count': len(wallet_list),
                        'total_equity': wallet_list[0].get('totalEquity') if wallet_list else None,
                        'error': None
                    }
                else:
                    tests['wallet_balance'] = {
                        'status': 'FAILED',
                        'response_time': round((end_time - start_time) * 1000, 2),
                        'error': data['retMsg']
                    }
            else:
                tests['wallet_balance'] = {
                    'status': 'FAILED',
                    'response_time': round((end_time - start_time) * 1000, 2),
                    'error': f"HTTP {response.status_code}: {response.text}"
                }
        except Exception as e:
            tests['wallet_balance'] = {
                'status': 'FAILED',
                'response_time': None,
                'error': str(e)
            }
        
        # í¬ì§€ì…˜ ì •ë³´ í…ŒìŠ¤íŠ¸
        try:
            timestamp = str(int(time.time() * 1000))
            params = {"category": "linear", "settleCoin": "USDT"}
            query_string = "&".join([f"{k}={v}" for k, v in params.items()])
            signature = self._generate_signature(timestamp, query_string)
            
            headers = {
                'X-BAPI-API-KEY': self.api_key,
                'X-BAPI-TIMESTAMP': timestamp,
                'X-BAPI-SIGN': signature,
                'X-BAPI-RECV-WINDOW': '5000'
            }
            
            start_time = time.time()
            response = requests.get(f"{self.base_url}/v5/position/list", 
                                  params=params, headers=headers, timeout=10)
            end_time = time.time()
            
            if response.status_code == 200:
                data = response.json()
                if data['retCode'] == 0:
                    positions = data['result']['list']
                    active_positions = [pos for pos in positions if float(pos.get('size', 0)) != 0]
                    
                    tests['position_info'] = {
                        'status': 'SUCCESS',
                        'response_time': round((end_time - start_time) * 1000, 2),
                        'total_positions': len(positions),
                        'active_positions': len(active_positions),
                        'error': None
                    }
                else:
                    tests['position_info'] = {
                        'status': 'FAILED',
                        'response_time': round((end_time - start_time) * 1000, 2),
                        'error': data['retMsg']
                    }
            else:
                tests['position_info'] = {
                    'status': 'FAILED',
                    'response_time': round((end_time - start_time) * 1000, 2),
                    'error': f"HTTP {response.status_code}: {response.text}"
                }
        except Exception as e:
            tests['position_info'] = {
                'status': 'FAILED',
                'response_time': None,
                'error': str(e)
            }
        
        return tests
    
    def test_websocket_connection(self, symbol="BTCUSDT"):
        """WebSocket ì—°ê²° í…ŒìŠ¤íŠ¸"""
        test_result = {
            'status': 'TESTING',
            'connection_time': None,
            'messages_received': 0,
            'error': None
        }
        
        def on_message(ws, message):
            test_result['messages_received'] += 1
            if test_result['messages_received'] >= 3:  # 3ê°œ ë©”ì‹œì§€ ë°›ìœ¼ë©´ ì¢…ë£Œ
                ws.close()
        
        def on_error(ws, error):
            test_result['status'] = 'FAILED'
            test_result['error'] = str(error)
        
        def on_close(ws, close_status_code, close_msg):
            if test_result['messages_received'] >= 3:
                test_result['status'] = 'SUCCESS'
        
        def on_open(ws):
            test_result['connection_time'] = time.time() - start_time
            # ê°€ê²© ìŠ¤íŠ¸ë¦¼ êµ¬ë…
            subscribe_msg = {
                "op": "subscribe",
                "args": [f"tickers.{symbol}"]
            }
            ws.send(json.dumps(subscribe_msg))
        
        try:
            start_time = time.time()
            ws = websocket.WebSocketApp(
                "wss://stream.bybit.com/v5/public/linear",
                on_message=on_message,
                on_error=on_error,
                on_close=on_close,
                on_open=on_open
            )
            
            # 5ì´ˆ íƒ€ì„ì•„ì›ƒìœ¼ë¡œ ì‹¤í–‰
            wst = threading.Thread(target=ws.run_forever, kwargs={'sslopt': {"cert_reqs": ssl.CERT_NONE}})
            wst.daemon = True
            wst.start()
            wst.join(timeout=5)
            
            if test_result['status'] == 'TESTING':
                test_result['status'] = 'TIMEOUT'
                test_result['error'] = '5ì´ˆ ë‚´ì— ì‘ë‹µ ì—†ìŒ'
            
        except Exception as e:
            test_result['status'] = 'FAILED'
            test_result['error'] = str(e)
        
        return test_result
```

### ğŸ§ª í†µí•© í…ŒìŠ¤íŠ¸ ì‹¤í–‰ê¸°

```python
class ComprehensiveAPITester:
    def __init__(self, binance_api_key=None, binance_secret=None, 
                 bybit_api_key=None, bybit_secret=None):
        self.binance_tester = BinanceAPITester(binance_api_key, binance_secret)
        self.bybit_tester = BybitAPITester(bybit_api_key, bybit_secret)
    
    def run_full_test_suite(self):
        """ì „ì²´ í…ŒìŠ¤íŠ¸ ìŠ¤ìœ„íŠ¸ ì‹¤í–‰"""
        print("ğŸš€ ì•”í˜¸í™”í ê±°ë˜ì†Œ API ì—°ê²° í…ŒìŠ¤íŠ¸ ì‹œì‘")
        print("=" * 60)
        
        results = {
            'timestamp': datetime.now().isoformat(),
            'binance': {},
            'bybit': {},
            'summary': {}
        }
        
        # ë°”ì´ë‚¸ìŠ¤ í…ŒìŠ¤íŠ¸
        print("\nğŸŸ¡ ë°”ì´ë‚¸ìŠ¤ API í…ŒìŠ¤íŠ¸ ì‹¤í–‰ ì¤‘...")
        results['binance'] = self._test_binance()
        
        # ë°”ì´ë¹„íŠ¸ í…ŒìŠ¤íŠ¸
        print("\nğŸŸ  ë°”ì´ë¹„íŠ¸ API í…ŒìŠ¤íŠ¸ ì‹¤í–‰ ì¤‘...")
        results['bybit'] = self._test_bybit()
        
        # ê²°ê³¼ ìš”ì•½
        results['summary'] = self._generate_summary(results)
        
        # ê²°ê³¼ ì¶œë ¥
        self._print_results(results)
        
        return results
    
    def _test_binance(self):
        """ë°”ì´ë‚¸ìŠ¤ ì „ì²´ í…ŒìŠ¤íŠ¸"""
        tests = {}
        
        print("  ğŸ“¡ ê¸°ë³¸ ì—°ê²° í…ŒìŠ¤íŠ¸...")
        tests['connection'] = self.binance_tester.test_connection()
        
        print("  ğŸ• ì„œë²„ ì‹œê°„ ë™ê¸°í™” í…ŒìŠ¤íŠ¸...")
        tests['server_time'] = self.binance_tester.test_server_time()
        
        print("  ğŸ“Š ê±°ë˜ì†Œ ì •ë³´ ì¡°íšŒ í…ŒìŠ¤íŠ¸...")
        tests['exchange_info'] = self.binance_tester.test_exchange_info()
        
        print("  ğŸ’¹ ì‹œì¥ ë°ì´í„° í…ŒìŠ¤íŠ¸...")
        tests['market_data'] = self.binance_tester.test_market_data()
        
        print("  ğŸ” ì¸ì¦ ì—”ë“œí¬ì¸íŠ¸ í…ŒìŠ¤íŠ¸...")
        tests['authenticated'] = self.binance_tester.test_authenticated_endpoints()
        
        print("  ğŸŒ WebSocket ì—°ê²° í…ŒìŠ¤íŠ¸...")
        tests['websocket'] = self.binance_tester.test_websocket_connection()
        
        return tests
    
    def _test_bybit(self):
        """ë°”ì´ë¹„íŠ¸ ì „ì²´ í…ŒìŠ¤íŠ¸"""
        tests = {}
        
        print("  ğŸ“¡ ê¸°ë³¸ ì—°ê²° í…ŒìŠ¤íŠ¸...")
        tests['connection'] = self.bybit_tester.test_connection()
        
        print("  ğŸ• ì„œë²„ ì‹œê°„ ë™ê¸°í™” í…ŒìŠ¤íŠ¸...")
        tests['server_time'] = self.bybit_tester.test_server_time()
        
        print("  ğŸ“Š ê±°ë˜ ìƒí’ˆ ì •ë³´ í…ŒìŠ¤íŠ¸...")
        tests['instruments_info'] = self.bybit_tester.test_instruments_info()
        
        print("  ğŸ’¹ ì‹œì¥ ë°ì´í„° í…ŒìŠ¤íŠ¸...")
        tests['market_data'] = self.bybit_tester.test_market_data()
        
        print("  ğŸ” ì¸ì¦ ì—”ë“œí¬ì¸íŠ¸ í…ŒìŠ¤íŠ¸...")
        tests['authenticated'] = self.bybit_tester.test_authenticated_endpoints()
        
        print("  ğŸŒ WebSocket ì—°ê²° í…ŒìŠ¤íŠ¸...")
        tests['websocket'] = self.bybit_tester.test_websocket_connection()
        
        return tests
    
    def _generate_summary(self, results):
        """í…ŒìŠ¤íŠ¸ ê²°ê³¼ ìš”ì•½ ìƒì„±"""
        summary = {
            'binance': {'total': 0, 'success': 0, 'failed': 0, 'skipped': 0},
            'bybit': {'total': 0, 'success': 0, 'failed': 0, 'skipped': 0},
            'overall': {'total': 0, 'success': 0, 'failed': 0, 'skipped': 0}
        }
        
        def count_results(test_data, exchange):
            for test_name, test_result in test_data.items():
                if isinstance(test_result, dict):
                    if 'status' in test_result:
                        summary[exchange]['total'] += 1
                        summary['overall']['total'] += 1
                        
                        status = test_result['status']
                        summary[exchange][status.lower()] += 1
                        summary['overall'][status.lower()] += 1
                    else:
                        # ì¤‘ì²©ëœ í…ŒìŠ¤íŠ¸ ê²°ê³¼ ì²˜ë¦¬
                        for sub_test_name, sub_test_result in test_result.items():
                            if isinstance(sub_test_result, dict) and 'status' in sub_test_result:
                                summary[exchange]['total'] += 1
                                summary['overall']['total'] += 1
                                
                                status = sub_test_result['status']
                                summary[exchange][status.lower()] += 1
                                summary['overall'][status.lower()] += 1
        
        count_results(results['binance'], 'binance')
        count_results(results['bybit'], 'bybit')
        
        return summary
    
    def _print_results(self, results):
        """í…ŒìŠ¤íŠ¸ ê²°ê³¼ ì¶œë ¥"""
        print("\n" + "=" * 60)
        print("ğŸ“Š API ì—°ê²° í…ŒìŠ¤íŠ¸ ê²°ê³¼ ìš”ì•½")
        print("=" * 60)
        
        summary = results['summary']
        
        # ì „ì²´ ìš”ì•½
        print(f"\nğŸ¯ ì „ì²´ í…ŒìŠ¤íŠ¸ ê²°ê³¼:")
        print(f"  ì´ í…ŒìŠ¤íŠ¸: {summary['overall']['total']}ê°œ")
        print(f"  ì„±ê³µ: {summary['overall']['success']}ê°œ âœ…")
        print(f"  ì‹¤íŒ¨: {summary['overall']['failed']}ê°œ âŒ")
        print(f"  ê±´ë„ˆëœ€: {summary['overall']['skipped']}ê°œ â­ï¸")
        
        success_rate = (summary['overall']['success'] / summary['overall']['total'] * 100) if summary['overall']['total'] > 0 else 0
        print(f"  ì„±ê³µë¥ : {success_rate:.1f}%")
        
        # ê±°ë˜ì†Œë³„ ìš”ì•½
        for exchange in ['binance', 'bybit']:
            emoji = "ğŸŸ¡" if exchange == 'binance' else "ğŸŸ "
            name = exchange.upper()
            
            print(f"\n{emoji} {name} í…ŒìŠ¤íŠ¸ ê²°ê³¼:")
            print(f"  ì´ í…ŒìŠ¤íŠ¸: {summary[exchange]['total']}ê°œ")
            print(f"  ì„±ê³µ: {summary[exchange]['success']}ê°œ âœ…")
            print(f"  ì‹¤íŒ¨: {summary[exchange]['failed']}ê°œ âŒ")
            print(f"  ê±´ë„ˆëœ€: {summary[exchange]['skipped']}ê°œ â­ï¸")
            
            exchange_success_rate = (summary[exchange]['success'] / summary[exchange]['total'] * 100) if summary[exchange]['total'] > 0 else 0
            print(f"  ì„±ê³µë¥ : {exchange_success_rate:.1f}%")
        
        # ìƒì„¸ ê²°ê³¼
        print("\n" + "=" * 60)
        print("ğŸ“‹ ìƒì„¸ í…ŒìŠ¤íŠ¸ ê²°ê³¼")
        print("=" * 60)
        
        self._print_detailed_results("ë°”ì´ë‚¸ìŠ¤", results['binance'])
        self._print_detailed_results("ë°”ì´ë¹„íŠ¸", results['bybit'])
    
    def _print_detailed_results(self, exchange_name, test_results):
        """ìƒì„¸ í…ŒìŠ¤íŠ¸ ê²°ê³¼ ì¶œë ¥"""
        print(f"\nğŸ” {exchange_name} ìƒì„¸ ê²°ê³¼:")
        
        for test_category, test_data in test_results.items():
            print(f"\n  ğŸ“‚ {test_category.upper()}:")
            
            if isinstance(test_data, dict) and 'status' in test_data:
                self._print_single_test_result(test_data, "    ")
            else:
                for test_name, test_result in test_data.items():
                    if isinstance(test_result, dict) and 'status' in test_result:
                        print(f"    ğŸ”¸ {test_name}:")
                        self._print_single_test_result(test_result, "      ")
    
    def _print_single_test_result(self, test_result, indent=""):
        """ë‹¨ì¼ í…ŒìŠ¤íŠ¸ ê²°ê³¼ ì¶œë ¥"""
        status = test_result.get('status', 'UNKNOWN')
        
        if status == 'SUCCESS':
            status_emoji = "âœ…"
        elif status == 'FAILED':
            status_emoji = "âŒ"
        elif status == 'SKIPPED':
            status_emoji = "â­ï¸"
        else:
            status_emoji = "â“"
        
        print(f"{indent}{status_emoji} ìƒíƒœ: {status}")
        
        if test_result.get('response_time'):
            print(f"{indent}â±ï¸  ì‘ë‹µì‹œê°„: {test_result['response_time']}ms")
        
        if test_result.get('error'):
            print(f"{indent}ğŸš¨ ì˜¤ë¥˜: {test_result['error']}")
        
        # ì¶”ê°€ ì •ë³´ ì¶œë ¥
        for key, value in test_result.items():
            if key not in ['status', 'response_time', 'error'] and value is not None:
                print(f"{indent}ğŸ“Š {key}: {value}")

# ì‚¬ìš© ì˜ˆì‹œ
def main():
    """ë©”ì¸ í…ŒìŠ¤íŠ¸ ì‹¤í–‰ í•¨ìˆ˜"""
    # API í‚¤ ì„¤ì • (ì‹¤ì œ ì‚¬ìš© ì‹œ í™˜ê²½ ë³€ìˆ˜ë‚˜ ì„¤ì • íŒŒì¼ì—ì„œ ë¡œë“œ)
    BINANCE_API_KEY = "your_binance_api_key_here"  # ì‹¤ì œ í‚¤ë¡œ êµì²´
    BINANCE_SECRET = "your_binance_secret_here"    # ì‹¤ì œ ì‹œí¬ë¦¿ìœ¼ë¡œ êµì²´
    BYBIT_API_KEY = "your_bybit_api_key_here"      # ì‹¤ì œ í‚¤ë¡œ êµì²´
    BYBIT_SECRET = "your_bybit_secret_here"        # ì‹¤ì œ ì‹œí¬ë¦¿ìœ¼ë¡œ êµì²´
    
    # API í‚¤ê°€ ì—†ì–´ë„ ê³µê°œ ì—”ë“œí¬ì¸íŠ¸ í…ŒìŠ¤íŠ¸ëŠ” ê°€ëŠ¥
    tester = ComprehensiveAPITester(
        binance_api_key=BINANCE_API_KEY if BINANCE_API_KEY != "your_binance_api_key_here" else None,
        binance_secret=BINANCE_SECRET if BINANCE_SECRET != "your_binance_secret_here" else None,
        bybit_api_key=BYBIT_API_KEY if BYBIT_API_KEY != "your_bybit_api_key_here" else None,
        bybit_secret=BYBIT_SECRET if BYBIT_SECRET != "your_bybit_secret_here" else None
    )
    
    # ì „ì²´ í…ŒìŠ¤íŠ¸ ì‹¤í–‰
    results = tester.run_full_test_suite()
    
    # ê²°ê³¼ë¥¼ JSON íŒŒì¼ë¡œ ì €ì¥
    with open('api_test_results.json', 'w', encoding='utf-8') as f:
        json.dump(results, f, indent=2, ensure_ascii=False)
    
    print(f"\nğŸ’¾ í…ŒìŠ¤íŠ¸ ê²°ê³¼ê°€ 'api_test_results.json' íŒŒì¼ë¡œ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.")
    
    return results

if __name__ == "__main__":
    main()
```

### ğŸ¯ ê°„ë‹¨í•œ ì—°ê²° í…ŒìŠ¤íŠ¸ ìŠ¤í¬ë¦½íŠ¸

```python
def quick_connection_test():
    """ë¹ ë¥¸ ì—°ê²° í…ŒìŠ¤íŠ¸ (API í‚¤ ë¶ˆí•„ìš”)"""
    print("âš¡ ë¹ ë¥¸ API ì—°ê²° í…ŒìŠ¤íŠ¸")
    print("-" * 40)
    
    # ë°”ì´ë‚¸ìŠ¤ í…ŒìŠ¤íŠ¸
    try:
        response = requests.get("https://fapi.binance.com/fapi/v1/ping", timeout=5)
        binance_status = "ğŸŸ¢ ì—°ê²°ë¨" if response.status_code == 200 else "ğŸ”´ ì—°ê²° ì‹¤íŒ¨"
    except:
        binance_status = "ğŸ”´ ì—°ê²° ì‹¤íŒ¨"
    
    # ë°”ì´ë¹„íŠ¸ í…ŒìŠ¤íŠ¸
    try:
        response = requests.get("https://api.bybit.com/v5/market/time", timeout=5)
        bybit_status = "ğŸŸ¢ ì—°ê²°ë¨" if response.status_code == 200 else "ğŸ”´ ì—°ê²° ì‹¤íŒ¨"
    except:
        bybit_status = "ğŸ”´ ì—°ê²° ì‹¤íŒ¨"
    
    print(f"ğŸŸ¡ ë°”ì´ë‚¸ìŠ¤: {binance_status}")
    print(f"ğŸŸ  ë°”ì´ë¹„íŠ¸: {bybit_status}")
    
    return binance_status, bybit_status

# ë¹ ë¥¸ í…ŒìŠ¤íŠ¸ ì‹¤í–‰
if __name__ == "__main__":
    quick_connection_test()
```

ì´ì œ ì™„ì „í•œ API ì—°ê²° í…ŒìŠ¤íŠ¸ ìŠ¤ìœ„íŠ¸ê°€ í¬í•¨ë˜ì—ˆìŠµë‹ˆë‹¤! ì´ í…ŒìŠ¤íŠ¸ë“¤ì„ í†µí•´ ì‹¤ì œ ê±°ë˜ì†Œ API ì—°ê²° ìƒíƒœ, ì‘ë‹µ ì‹œê°„, ë°ì´í„° í’ˆì§ˆ ë“±ì„ ì¢…í•©ì ìœ¼ë¡œ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
